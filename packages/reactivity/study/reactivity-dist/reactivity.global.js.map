{"version":3,"file":"reactivity.global.js","sources":["../../shared/src/makeMap.ts","../../shared/src/index.ts","../src/effect.ts","../src/baseHandlers.ts","../src/collectionHandlers.ts","../src/reactive.ts","../src/ref.ts","../src/computed.ts"],"sourcesContent":["/**\r\n * Make a map and return a function for checking if a key\r\n * is in that map.\r\n * IMPORTANT: all calls of this function must be prefixed with\r\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\r\n * So that rollup can tree-shake them if necessary.\r\n */\r\nexport function makeMap(\r\n  str: string,\r\n  expectsLowerCase?: boolean\r\n): (key: string) => boolean {\r\n  const map: Record<string, boolean> = Object.create(null)\r\n  const list: Array<string> = str.split(',')\r\n  for (let i = 0; i < list.length; i++) {\r\n    map[list[i]] = true\r\n  }\r\n  return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val]\r\n}\r\n","import { makeMap } from './makeMap'\r\n\r\nexport { makeMap }\r\nexport * from './patchFlags'\r\nexport * from './shapeFlags'\r\nexport * from './slotFlags'\r\nexport * from './globalsWhitelist'\r\nexport * from './codeframe'\r\nexport * from './normalizeProp'\r\nexport * from './domTagConfig'\r\nexport * from './domAttrConfig'\r\nexport * from './escapeHtml'\r\nexport * from './looseEqual'\r\nexport * from './toDisplayString'\r\n\r\n/**\r\n * List of @babel/parser plugins that are used for template expression\r\n * transforms and SFC script transforms. By default we enable proposals slated\r\n * for ES2020. This will need to be updated as the spec moves forward.\r\n * Full list at https://babeljs.io/docs/en/next/babel-parser#plugins\r\n */\r\nexport const babelParserDefautPlugins = [\r\n  'bigInt',\r\n  'optionalChaining',\r\n  'nullishCoalescingOperator'\r\n] as const\r\n\r\nexport const EMPTY_OBJ: { readonly [key: string]: any } = __DEV__\r\n  ? Object.freeze({})\r\n  : {}\r\nexport const EMPTY_ARR: [] = []\r\n\r\nexport const NOOP = () => {}\r\n\r\n/**\r\n * Always return false.\r\n */\r\nexport const NO = () => false\r\n\r\nconst onRE = /^on[^a-z]/\r\nexport const isOn = (key: string) => onRE.test(key)\r\n\r\nexport const isModelListener = (key: string) => key.startsWith('onUpdate:')\r\n\r\nexport const extend = Object.assign\r\n\r\nexport const remove = <T>(arr: T[], el: T) => {\r\n  const i = arr.indexOf(el)\r\n  if (i > -1) {\r\n    arr.splice(i, 1)\r\n  }\r\n}\r\n\r\nconst hasOwnProperty = Object.prototype.hasOwnProperty\r\nexport const hasOwn = (\r\n  val: object,\r\n  key: string | symbol\r\n): key is keyof typeof val => hasOwnProperty.call(val, key)\r\n\r\nexport const isArray = Array.isArray\r\nexport const isDate = (val: unknown): val is Date => val instanceof Date\r\nexport const isFunction = (val: unknown): val is Function =>\r\n  typeof val === 'function'\r\nexport const isString = (val: unknown): val is string => typeof val === 'string'\r\nexport const isSymbol = (val: unknown): val is symbol => typeof val === 'symbol'\r\nexport const isObject = (val: unknown): val is Record<any, any> =>\r\n  val !== null && typeof val === 'object'\r\n\r\nexport const isPromise = <T = any>(val: unknown): val is Promise<T> => {\r\n  return isObject(val) && isFunction(val.then) && isFunction(val.catch)\r\n}\r\n\r\nexport const objectToString = Object.prototype.toString\r\nexport const toTypeString = (value: unknown): string =>\r\n  objectToString.call(value)\r\n\r\nexport const toRawType = (value: unknown): string => {\r\n  return toTypeString(value).slice(8, -1)\r\n}\r\n\r\nexport const isPlainObject = (val: unknown): val is object =>\r\n  toTypeString(val) === '[object Object]'\r\n\r\nexport const isReservedProp = /*#__PURE__*/ makeMap(\r\n  'key,ref,' +\r\n    'onVnodeBeforeMount,onVnodeMounted,' +\r\n    'onVnodeBeforeUpdate,onVnodeUpdated,' +\r\n    'onVnodeBeforeUnmount,onVnodeUnmounted'\r\n)\r\n\r\nconst cacheStringFunction = <T extends (str: string) => string>(fn: T): T => {\r\n  const cache: Record<string, string> = Object.create(null)\r\n  return ((str: string) => {\r\n    const hit = cache[str]\r\n    return hit || (cache[str] = fn(str))\r\n  }) as any\r\n}\r\n\r\nconst camelizeRE = /-(\\w)/g\r\n/**\r\n * @private\r\n */\r\nexport const camelize = cacheStringFunction(\r\n  (str: string): string => {\r\n    return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''))\r\n  }\r\n)\r\n\r\nconst hyphenateRE = /\\B([A-Z])/g\r\n/**\r\n * @private\r\n */\r\nexport const hyphenate = cacheStringFunction(\r\n  (str: string): string => {\r\n    return str.replace(hyphenateRE, '-$1').toLowerCase()\r\n  }\r\n)\r\n\r\n/**\r\n * @private\r\n */\r\nexport const capitalize = cacheStringFunction(\r\n  (str: string): string => {\r\n    return str.charAt(0).toUpperCase() + str.slice(1)\r\n  }\r\n)\r\n\r\n// compare whether a value has changed, accounting for NaN.\r\nexport const hasChanged = (value: any, oldValue: any): boolean =>\r\n  value !== oldValue && (value === value || oldValue === oldValue)\r\n\r\nexport const invokeArrayFns = (fns: Function[], arg?: any) => {\r\n  for (let i = 0; i < fns.length; i++) {\r\n    fns[i](arg)\r\n  }\r\n}\r\n\r\nexport const def = (obj: object, key: string | symbol, value: any) => {\r\n  Object.defineProperty(obj, key, {\r\n    configurable: true,\r\n    enumerable: false,\r\n    value\r\n  })\r\n}\r\n\r\nexport const toNumber = (val: any): any => {\r\n  const n = parseFloat(val)\r\n  return isNaN(n) ? val : n\r\n}\r\n\r\nlet _globalThis: any\r\nexport const getGlobalThis = (): any => {\r\n  return (\r\n    _globalThis ||\r\n    (_globalThis =\r\n      typeof globalThis !== 'undefined'\r\n        ? globalThis\r\n        : typeof self !== 'undefined'\r\n          ? self\r\n          : typeof window !== 'undefined'\r\n            ? window\r\n            : typeof global !== 'undefined'\r\n              ? global\r\n              : {})\r\n  )\r\n}\r\n","import { TrackOpTypes, TriggerOpTypes } from './operations'\r\nimport { EMPTY_OBJ, isArray } from '@vue/shared'\r\n\r\n// The main WeakMap that stores {target -> key -> dep} connections.\r\n// Conceptually, it's easier to think of a dependency as a Dep class\r\n// which maintains a Set of subscribers, but we simply store them as\r\n// raw Sets to reduce memory overhead.\r\ntype Dep = Set<ReactiveEffect>\r\ntype KeyToDepMap = Map<any, Dep>\r\nconst targetMap = new WeakMap<any, KeyToDepMap>()\r\n\r\nexport interface ReactiveEffect<T = any> {\r\n  (): T\r\n  _isEffect: true\r\n  id: number\r\n  active: boolean\r\n  raw: () => T\r\n  deps: Array<Dep>\r\n  options: ReactiveEffectOptions\r\n}\r\n\r\nexport interface ReactiveEffectOptions {\r\n  lazy?: boolean\r\n  scheduler?: (job: ReactiveEffect) => void\r\n  onTrack?: (event: DebuggerEvent) => void\r\n  onTrigger?: (event: DebuggerEvent) => void\r\n  onStop?: () => void\r\n}\r\n\r\nexport type DebuggerEvent = {\r\n  effect: ReactiveEffect\r\n  target: object\r\n  type: TrackOpTypes | TriggerOpTypes\r\n  key: any\r\n} & DebuggerEventExtraInfo\r\n\r\nexport interface DebuggerEventExtraInfo {\r\n  newValue?: any\r\n  oldValue?: any\r\n  oldTarget?: Map<any, any> | Set<any>\r\n}\r\n\r\nconst effectStack: ReactiveEffect[] = []\r\nlet activeEffect: ReactiveEffect | undefined\r\n\r\nexport const ITERATE_KEY = Symbol(__DEV__ ? 'iterate' : '')\r\nexport const MAP_KEY_ITERATE_KEY = Symbol(__DEV__ ? 'Map key iterate' : '')\r\n\r\nexport function isEffect(fn: any): fn is ReactiveEffect {\r\n  return fn && fn._isEffect === true\r\n}\r\n\r\nexport function effect<T = any>(\r\n  fn: () => T,\r\n  options: ReactiveEffectOptions = EMPTY_OBJ\r\n): ReactiveEffect<T> {\r\n  if (isEffect(fn)) {\r\n    fn = fn.raw\r\n  }\r\n  const effect = createReactiveEffect(fn, options)\r\n  if (!options.lazy) {\r\n    effect()\r\n  }\r\n  return effect\r\n}\r\n\r\nexport function stop(effect: ReactiveEffect) {\r\n  if (effect.active) {\r\n    cleanup(effect)\r\n    if (effect.options.onStop) {\r\n      effect.options.onStop()\r\n    }\r\n    effect.active = false\r\n  }\r\n}\r\n\r\nlet uid = 0\r\n\r\nfunction createReactiveEffect<T = any>(\r\n  fn: () => T,\r\n  options: ReactiveEffectOptions\r\n): ReactiveEffect<T> {\r\n  const effect = function reactiveEffect(): unknown {\r\n    if (!effect.active) {\r\n      return options.scheduler ? undefined : fn()\r\n    }\r\n    if (!effectStack.includes(effect)) {\r\n      cleanup(effect)\r\n      try {\r\n        enableTracking()\r\n        effectStack.push(effect)\r\n        activeEffect = effect\r\n        return fn()\r\n      } finally {\r\n        effectStack.pop()\r\n        resetTracking()\r\n        activeEffect = effectStack[effectStack.length - 1]\r\n      }\r\n    }\r\n  } as ReactiveEffect\r\n  effect.id = uid++\r\n  effect._isEffect = true\r\n  effect.active = true\r\n  effect.raw = fn\r\n  effect.deps = []\r\n  effect.options = options\r\n  return effect\r\n}\r\n\r\nfunction cleanup(effect: ReactiveEffect) {\r\n  const { deps } = effect\r\n  if (deps.length) {\r\n    for (let i = 0; i < deps.length; i++) {\r\n      deps[i].delete(effect)\r\n    }\r\n    deps.length = 0\r\n  }\r\n}\r\n\r\nlet shouldTrack = true\r\nconst trackStack: boolean[] = []\r\n\r\nexport function pauseTracking() {\r\n  trackStack.push(shouldTrack)\r\n  shouldTrack = false\r\n}\r\n\r\nexport function enableTracking() {\r\n  trackStack.push(shouldTrack)\r\n  shouldTrack = true\r\n}\r\n\r\nexport function resetTracking() {\r\n  const last = trackStack.pop()\r\n  shouldTrack = last === undefined ? true : last\r\n}\r\n\r\nexport function track(target: object, type: TrackOpTypes, key: unknown) {\r\n  if (!shouldTrack || activeEffect === undefined) {\r\n    return\r\n  }\r\n  let depsMap = targetMap.get(target)\r\n  if (!depsMap) {\r\n    targetMap.set(target, (depsMap = new Map()))\r\n  }\r\n  let dep = depsMap.get(key)\r\n  if (!dep) {\r\n    depsMap.set(key, (dep = new Set()))\r\n  }\r\n  if (!dep.has(activeEffect)) {\r\n    dep.add(activeEffect)\r\n    activeEffect.deps.push(dep)\r\n    if (__DEV__ && activeEffect.options.onTrack) {\r\n      activeEffect.options.onTrack({\r\n        effect: activeEffect,\r\n        target,\r\n        type,\r\n        key\r\n      })\r\n    }\r\n  }\r\n}\r\n\r\nexport function trigger(\r\n  target: object,\r\n  type: TriggerOpTypes,\r\n  key?: unknown,\r\n  newValue?: unknown,\r\n  oldValue?: unknown,\r\n  oldTarget?: Map<unknown, unknown> | Set<unknown>\r\n) {\r\n  const depsMap = targetMap.get(target)\r\n  if (!depsMap) {\r\n    // never been tracked\r\n    return\r\n  }\r\n\r\n  const effects = new Set<ReactiveEffect>()\r\n  const add = (effectsToAdd: Set<ReactiveEffect> | undefined) => {\r\n    if (effectsToAdd) {\r\n      effectsToAdd.forEach(effect => effects.add(effect))\r\n    }\r\n  }\r\n\r\n  if (type === TriggerOpTypes.CLEAR) {\r\n    // collection being cleared\r\n    // trigger all effects for target\r\n    depsMap.forEach(add)\r\n  } else if (key === 'length' && isArray(target)) {\r\n    depsMap.forEach((dep, key) => {\r\n      if (key === 'length' || key >= (newValue as number)) {\r\n        add(dep)\r\n      }\r\n    })\r\n  } else {\r\n    // schedule runs for SET | ADD | DELETE\r\n    if (key !== void 0) {\r\n      add(depsMap.get(key))\r\n    }\r\n    // also run for iteration key on ADD | DELETE | Map.SET\r\n    const isAddOrDelete =\r\n      type === TriggerOpTypes.ADD ||\r\n      (type === TriggerOpTypes.DELETE && !isArray(target))\r\n    if (\r\n      isAddOrDelete ||\r\n      (type === TriggerOpTypes.SET && target instanceof Map)\r\n    ) {\r\n      add(depsMap.get(isArray(target) ? 'length' : ITERATE_KEY))\r\n    }\r\n    if (isAddOrDelete && target instanceof Map) {\r\n      add(depsMap.get(MAP_KEY_ITERATE_KEY))\r\n    }\r\n  }\r\n\r\n  const run = (effect: ReactiveEffect) => {\r\n    if (__DEV__ && effect.options.onTrigger) {\r\n      effect.options.onTrigger({\r\n        effect,\r\n        target,\r\n        key,\r\n        type,\r\n        newValue,\r\n        oldValue,\r\n        oldTarget\r\n      })\r\n    }\r\n    if (effect.options.scheduler) {\r\n      effect.options.scheduler(effect)\r\n    } else {\r\n      effect()\r\n    }\r\n  }\r\n\r\n  effects.forEach(run)\r\n}\r\n","import { reactive, readonly, toRaw, ReactiveFlags } from './reactive'\r\nimport { TrackOpTypes, TriggerOpTypes } from './operations'\r\nimport { track, trigger, ITERATE_KEY } from './effect'\r\nimport {\r\n  isObject,\r\n  hasOwn,\r\n  isSymbol,\r\n  hasChanged,\r\n  isArray,\r\n  extend\r\n} from '@vue/shared'\r\nimport { isRef } from './ref'\r\n\r\nconst builtInSymbols = new Set(\r\n  Object.getOwnPropertyNames(Symbol)\r\n    .map(key => (Symbol as any)[key])\r\n    .filter(isSymbol)\r\n)\r\n\r\nconst get = /*#__PURE__*/ createGetter()\r\nconst shallowGet = /*#__PURE__*/ createGetter(false, true)\r\nconst readonlyGet = /*#__PURE__*/ createGetter(true)\r\nconst shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true)\r\n\r\nconst arrayInstrumentations: Record<string, Function> = {}\r\n;['includes', 'indexOf', 'lastIndexOf'].forEach(key => {\r\n  arrayInstrumentations[key] = function(...args: any[]): any {\r\n    const arr = toRaw(this) as any\r\n    for (let i = 0, l = (this as any).length; i < l; i++) {\r\n      track(arr, TrackOpTypes.GET, i + '')\r\n    }\r\n    // we run the method using the original args first (which may be reactive)\r\n    const res = arr[key](...args)\r\n    if (res === -1 || res === false) {\r\n      // if that didn't work, run it again using raw values.\r\n      return arr[key](...args.map(toRaw))\r\n    } else {\r\n      return res\r\n    }\r\n  }\r\n})\r\n\r\nfunction createGetter(isReadonly = false, shallow = false) {\r\n  return function get(target: object, key: string | symbol, receiver: object) {\r\n    if (key === ReactiveFlags.IS_REACTIVE) {\r\n      return !isReadonly\r\n    } else if (key === ReactiveFlags.IS_READONLY) {\r\n      return isReadonly\r\n    } else if (\r\n      key === ReactiveFlags.RAW &&\r\n      receiver ===\r\n        (isReadonly\r\n          ? (target as any)[ReactiveFlags.READONLY]\r\n          : (target as any)[ReactiveFlags.REACTIVE])\r\n    ) {\r\n      return target\r\n    }\r\n\r\n    const targetIsArray = isArray(target)\r\n    if (targetIsArray && hasOwn(arrayInstrumentations, key)) {\r\n      return Reflect.get(arrayInstrumentations, key, receiver)\r\n    }\r\n\r\n    const res = Reflect.get(target, key, receiver)\r\n\r\n    if (\r\n      isSymbol(key)\r\n        ? builtInSymbols.has(key)\r\n        : key === `__proto__` || key === `__v_isRef`\r\n    ) {\r\n      return res\r\n    }\r\n\r\n    if (!isReadonly) {\r\n      track(target, TrackOpTypes.GET, key)\r\n    }\r\n\r\n    if (shallow) {\r\n      return res\r\n    }\r\n\r\n    if (isRef(res)) {\r\n      // ref unwrapping, only for Objects, not for Arrays.\r\n      return targetIsArray ? res : res.value\r\n    }\r\n\r\n    if (isObject(res)) {\r\n      // Convert returned value into a proxy as well. we do the isObject check\r\n      // here to avoid invalid value warning. Also need to lazy access readonly\r\n      // and reactive here to avoid circular dependency.\r\n      return isReadonly ? readonly(res) : reactive(res)\r\n    }\r\n\r\n    return res\r\n  }\r\n}\r\n\r\nconst set = /*#__PURE__*/ createSetter()\r\nconst shallowSet = /*#__PURE__*/ createSetter(true)\r\n\r\nfunction createSetter(shallow = false) {\r\n  return function set(\r\n    target: object,\r\n    key: string | symbol,\r\n    value: unknown,\r\n    receiver: object\r\n  ): boolean {\r\n    const oldValue = (target as any)[key]\r\n    if (!shallow) {\r\n      value = toRaw(value)\r\n      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\r\n        oldValue.value = value\r\n        return true\r\n      }\r\n    } else {\r\n      // in shallow mode, objects are set as-is regardless of reactive or not\r\n    }\r\n\r\n    const hadKey = hasOwn(target, key)\r\n    const result = Reflect.set(target, key, value, receiver)\r\n    // don't trigger if target is something up in the prototype chain of original\r\n    if (target === toRaw(receiver)) {\r\n      if (!hadKey) {\r\n        trigger(target, TriggerOpTypes.ADD, key, value)\r\n      } else if (hasChanged(value, oldValue)) {\r\n        trigger(target, TriggerOpTypes.SET, key, value, oldValue)\r\n      }\r\n    }\r\n    return result\r\n  }\r\n}\r\n\r\nfunction deleteProperty(target: object, key: string | symbol): boolean {\r\n  const hadKey = hasOwn(target, key)\r\n  const oldValue = (target as any)[key]\r\n  const result = Reflect.deleteProperty(target, key)\r\n  if (result && hadKey) {\r\n    trigger(target, TriggerOpTypes.DELETE, key, undefined, oldValue)\r\n  }\r\n  return result\r\n}\r\n\r\nfunction has(target: object, key: string | symbol): boolean {\r\n  const result = Reflect.has(target, key)\r\n  if (!isSymbol(key) || !builtInSymbols.has(key)) {\r\n    track(target, TrackOpTypes.HAS, key)\r\n  }\r\n  return result\r\n}\r\n\r\nfunction ownKeys(target: object): (string | number | symbol)[] {\r\n  track(target, TrackOpTypes.ITERATE, ITERATE_KEY)\r\n  return Reflect.ownKeys(target)\r\n}\r\n\r\nexport const mutableHandlers: ProxyHandler<object> = {\r\n  get,\r\n  set,\r\n  deleteProperty,\r\n  has,\r\n  ownKeys\r\n}\r\n\r\nexport const readonlyHandlers: ProxyHandler<object> = {\r\n  get: readonlyGet,\r\n  has,\r\n  ownKeys,\r\n  set(target, key) {\r\n    if (__DEV__) {\r\n      console.warn(\r\n        `Set operation on key \"${String(key)}\" failed: target is readonly.`,\r\n        target\r\n      )\r\n    }\r\n    return true\r\n  },\r\n  deleteProperty(target, key) {\r\n    if (__DEV__) {\r\n      console.warn(\r\n        `Delete operation on key \"${String(key)}\" failed: target is readonly.`,\r\n        target\r\n      )\r\n    }\r\n    return true\r\n  }\r\n}\r\n\r\nexport const shallowReactiveHandlers: ProxyHandler<object> = extend(\r\n  {},\r\n  mutableHandlers,\r\n  {\r\n    get: shallowGet,\r\n    set: shallowSet\r\n  }\r\n)\r\n\r\n// Props handlers are special in the sense that it should not unwrap top-level\r\n// refs (in order to allow refs to be explicitly passed down), but should\r\n// retain the reactivity of the normal readonly object.\r\nexport const shallowReadonlyHandlers: ProxyHandler<object> = extend(\r\n  {},\r\n  readonlyHandlers,\r\n  {\r\n    get: shallowReadonlyGet\r\n  }\r\n)\r\n","import { toRaw, reactive, readonly, ReactiveFlags } from './reactive'\r\nimport { track, trigger, ITERATE_KEY, MAP_KEY_ITERATE_KEY } from './effect'\r\nimport { TrackOpTypes, TriggerOpTypes } from './operations'\r\nimport {\r\n  isObject,\r\n  capitalize,\r\n  hasOwn,\r\n  hasChanged,\r\n  toRawType\r\n} from '@vue/shared'\r\n\r\nexport type CollectionTypes = IterableCollections | WeakCollections\r\n\r\ntype IterableCollections = Map<any, any> | Set<any>\r\ntype WeakCollections = WeakMap<any, any> | WeakSet<any>\r\ntype MapTypes = Map<any, any> | WeakMap<any, any>\r\ntype SetTypes = Set<any> | WeakSet<any>\r\n\r\nconst toReactive = <T extends unknown>(value: T): T =>\r\n  isObject(value) ? reactive(value) : value\r\n\r\nconst toReadonly = <T extends unknown>(value: T): T =>\r\n  isObject(value) ? readonly(value) : value\r\n\r\nconst toShallow = <T extends unknown>(value: T): T => value\r\n\r\nconst getProto = <T extends CollectionTypes>(v: T): any =>\r\n  Reflect.getPrototypeOf(v)\r\n\r\nfunction get(\r\n  target: MapTypes,\r\n  key: unknown,\r\n  wrap: typeof toReactive | typeof toReadonly | typeof toShallow\r\n) {\r\n  target = toRaw(target)\r\n  const rawKey = toRaw(key)\r\n  if (key !== rawKey) {\r\n    track(target, TrackOpTypes.GET, key)\r\n  }\r\n  track(target, TrackOpTypes.GET, rawKey)\r\n  const { has, get } = getProto(target)\r\n  if (has.call(target, key)) {\r\n    return wrap(get.call(target, key))\r\n  } else if (has.call(target, rawKey)) {\r\n    return wrap(get.call(target, rawKey))\r\n  }\r\n}\r\n\r\nfunction has(this: CollectionTypes, key: unknown): boolean {\r\n  const target = toRaw(this)\r\n  const rawKey = toRaw(key)\r\n  if (key !== rawKey) {\r\n    track(target, TrackOpTypes.HAS, key)\r\n  }\r\n  track(target, TrackOpTypes.HAS, rawKey)\r\n  const has = getProto(target).has\r\n  return has.call(target, key) || has.call(target, rawKey)\r\n}\r\n\r\nfunction size(target: IterableCollections) {\r\n  target = toRaw(target)\r\n  track(target, TrackOpTypes.ITERATE, ITERATE_KEY)\r\n  return Reflect.get(getProto(target), 'size', target)\r\n}\r\n\r\nfunction add(this: SetTypes, value: unknown) {\r\n  value = toRaw(value)\r\n  const target = toRaw(this)\r\n  const proto = getProto(target)\r\n  const hadKey = proto.has.call(target, value)\r\n  const result = proto.add.call(target, value)\r\n  if (!hadKey) {\r\n    trigger(target, TriggerOpTypes.ADD, value, value)\r\n  }\r\n  return result\r\n}\r\n\r\nfunction set(this: MapTypes, key: unknown, value: unknown) {\r\n  value = toRaw(value)\r\n  const target = toRaw(this)\r\n  const { has, get, set } = getProto(target)\r\n\r\n  let hadKey = has.call(target, key)\r\n  if (!hadKey) {\r\n    key = toRaw(key)\r\n    hadKey = has.call(target, key)\r\n  } else if (__DEV__) {\r\n    checkIdentityKeys(target, has, key)\r\n  }\r\n\r\n  const oldValue = get.call(target, key)\r\n  const result = set.call(target, key, value)\r\n  if (!hadKey) {\r\n    trigger(target, TriggerOpTypes.ADD, key, value)\r\n  } else if (hasChanged(value, oldValue)) {\r\n    trigger(target, TriggerOpTypes.SET, key, value, oldValue)\r\n  }\r\n  return result\r\n}\r\n\r\nfunction deleteEntry(this: CollectionTypes, key: unknown) {\r\n  const target = toRaw(this)\r\n  const { has, get, delete: del } = getProto(target)\r\n  let hadKey = has.call(target, key)\r\n  if (!hadKey) {\r\n    key = toRaw(key)\r\n    hadKey = has.call(target, key)\r\n  } else if (__DEV__) {\r\n    checkIdentityKeys(target, has, key)\r\n  }\r\n\r\n  const oldValue = get ? get.call(target, key) : undefined\r\n  // forward the operation before queueing reactions\r\n  const result = del.call(target, key)\r\n  if (hadKey) {\r\n    trigger(target, TriggerOpTypes.DELETE, key, undefined, oldValue)\r\n  }\r\n  return result\r\n}\r\n\r\nfunction clear(this: IterableCollections) {\r\n  const target = toRaw(this)\r\n  const hadItems = target.size !== 0\r\n  const oldTarget = __DEV__\r\n    ? target instanceof Map\r\n      ? new Map(target)\r\n      : new Set(target)\r\n    : undefined\r\n  // forward the operation before queueing reactions\r\n  const result = getProto(target).clear.call(target)\r\n  if (hadItems) {\r\n    trigger(target, TriggerOpTypes.CLEAR, undefined, undefined, oldTarget)\r\n  }\r\n  return result\r\n}\r\n\r\nfunction createForEach(isReadonly: boolean, shallow: boolean) {\r\n  return function forEach(\r\n    this: IterableCollections,\r\n    callback: Function,\r\n    thisArg?: unknown\r\n  ) {\r\n    const observed = this\r\n    const target = toRaw(observed)\r\n    const wrap = isReadonly ? toReadonly : shallow ? toShallow : toReactive\r\n    !isReadonly && track(target, TrackOpTypes.ITERATE, ITERATE_KEY)\r\n    // important: create sure the callback is\r\n    // 1. invoked with the reactive map as `this` and 3rd arg\r\n    // 2. the value received should be a corresponding reactive/readonly.\r\n    function wrappedCallback(value: unknown, key: unknown) {\r\n      return callback.call(thisArg, wrap(value), wrap(key), observed)\r\n    }\r\n    return getProto(target).forEach.call(target, wrappedCallback)\r\n  }\r\n}\r\n\r\ninterface Iterable {\r\n  [Symbol.iterator](): Iterator\r\n}\r\n\r\ninterface Iterator {\r\n  next(value?: any): IterationResult\r\n}\r\n\r\ninterface IterationResult {\r\n  value: any\r\n  done: boolean\r\n}\r\n\r\nfunction createIterableMethod(\r\n  method: string | symbol,\r\n  isReadonly: boolean,\r\n  shallow: boolean\r\n) {\r\n  return function(\r\n    this: IterableCollections,\r\n    ...args: unknown[]\r\n  ): Iterable & Iterator {\r\n    const target = toRaw(this)\r\n    const isMap = target instanceof Map\r\n    const isPair = method === 'entries' || (method === Symbol.iterator && isMap)\r\n    const isKeyOnly = method === 'keys' && isMap\r\n    const innerIterator = getProto(target)[method].apply(target, args)\r\n    const wrap = isReadonly ? toReadonly : shallow ? toShallow : toReactive\r\n    !isReadonly &&\r\n      track(\r\n        target,\r\n        TrackOpTypes.ITERATE,\r\n        isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY\r\n      )\r\n    // return a wrapped iterator which returns observed versions of the\r\n    // values emitted from the real iterator\r\n    return {\r\n      // iterator protocol\r\n      next() {\r\n        const { value, done } = innerIterator.next()\r\n        return done\r\n          ? { value, done }\r\n          : {\r\n              value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\r\n              done\r\n            }\r\n      },\r\n      // iterable protocol\r\n      [Symbol.iterator]() {\r\n        return this\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction createReadonlyMethod(type: TriggerOpTypes): Function {\r\n  return function(this: CollectionTypes, ...args: unknown[]) {\r\n    if (__DEV__) {\r\n      const key = args[0] ? `on key \"${args[0]}\" ` : ``\r\n      console.warn(\r\n        `${capitalize(type)} operation ${key}failed: target is readonly.`,\r\n        toRaw(this)\r\n      )\r\n    }\r\n    return type === TriggerOpTypes.DELETE ? false : this\r\n  }\r\n}\r\n\r\nconst mutableInstrumentations: Record<string, Function> = {\r\n  get(this: MapTypes, key: unknown) {\r\n    return get(this, key, toReactive)\r\n  },\r\n  get size() {\r\n    return size((this as unknown) as IterableCollections)\r\n  },\r\n  has,\r\n  add,\r\n  set,\r\n  delete: deleteEntry,\r\n  clear,\r\n  forEach: createForEach(false, false)\r\n}\r\n\r\nconst shallowInstrumentations: Record<string, Function> = {\r\n  get(this: MapTypes, key: unknown) {\r\n    return get(this, key, toShallow)\r\n  },\r\n  get size() {\r\n    return size((this as unknown) as IterableCollections)\r\n  },\r\n  has,\r\n  add,\r\n  set,\r\n  delete: deleteEntry,\r\n  clear,\r\n  forEach: createForEach(false, true)\r\n}\r\n\r\nconst readonlyInstrumentations: Record<string, Function> = {\r\n  get(this: MapTypes, key: unknown) {\r\n    return get(this, key, toReadonly)\r\n  },\r\n  get size() {\r\n    return size((this as unknown) as IterableCollections)\r\n  },\r\n  has,\r\n  add: createReadonlyMethod(TriggerOpTypes.ADD),\r\n  set: createReadonlyMethod(TriggerOpTypes.SET),\r\n  delete: createReadonlyMethod(TriggerOpTypes.DELETE),\r\n  clear: createReadonlyMethod(TriggerOpTypes.CLEAR),\r\n  forEach: createForEach(true, false)\r\n}\r\n\r\nconst iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator]\r\niteratorMethods.forEach(method => {\r\n  mutableInstrumentations[method as string] = createIterableMethod(\r\n    method,\r\n    false,\r\n    false\r\n  )\r\n  readonlyInstrumentations[method as string] = createIterableMethod(\r\n    method,\r\n    true,\r\n    false\r\n  )\r\n  shallowInstrumentations[method as string] = createIterableMethod(\r\n    method,\r\n    false,\r\n    true\r\n  )\r\n})\r\n\r\nfunction createInstrumentationGetter(isReadonly: boolean, shallow: boolean) {\r\n  const instrumentations = shallow\r\n    ? shallowInstrumentations\r\n    : isReadonly\r\n      ? readonlyInstrumentations\r\n      : mutableInstrumentations\r\n\r\n  return (\r\n    target: CollectionTypes,\r\n    key: string | symbol,\r\n    receiver: CollectionTypes\r\n  ) => {\r\n    if (key === ReactiveFlags.IS_REACTIVE) {\r\n      return !isReadonly\r\n    } else if (key === ReactiveFlags.IS_READONLY) {\r\n      return isReadonly\r\n    } else if (key === ReactiveFlags.RAW) {\r\n      return target\r\n    }\r\n\r\n    return Reflect.get(\r\n      hasOwn(instrumentations, key) && key in target\r\n        ? instrumentations\r\n        : target,\r\n      key,\r\n      receiver\r\n    )\r\n  }\r\n}\r\n\r\nexport const mutableCollectionHandlers: ProxyHandler<CollectionTypes> = {\r\n  get: createInstrumentationGetter(false, false)\r\n}\r\n\r\nexport const shallowCollectionHandlers: ProxyHandler<CollectionTypes> = {\r\n  get: createInstrumentationGetter(false, true)\r\n}\r\n\r\nexport const readonlyCollectionHandlers: ProxyHandler<CollectionTypes> = {\r\n  get: createInstrumentationGetter(true, false)\r\n}\r\n\r\nfunction checkIdentityKeys(\r\n  target: CollectionTypes,\r\n  has: (key: unknown) => boolean,\r\n  key: unknown\r\n) {\r\n  const rawKey = toRaw(key)\r\n  if (rawKey !== key && has.call(target, rawKey)) {\r\n    const type = toRawType(target)\r\n    console.warn(\r\n      `Reactive ${type} contains both the raw and reactive ` +\r\n        `versions of the same object${type === `Map` ? `as keys` : ``}, ` +\r\n        `which can lead to inconsistencies. ` +\r\n        `Avoid differentiating between the raw and reactive versions ` +\r\n        `of an object and only use the reactive version if possible.`\r\n    )\r\n  }\r\n}\r\n","import { isObject, toRawType, def, hasOwn, makeMap } from '@vue/shared'\r\nimport {\r\n  mutableHandlers,\r\n  readonlyHandlers,\r\n  shallowReactiveHandlers,\r\n  shallowReadonlyHandlers\r\n} from './baseHandlers'\r\nimport {\r\n  mutableCollectionHandlers,\r\n  readonlyCollectionHandlers,\r\n  shallowCollectionHandlers\r\n} from './collectionHandlers'\r\nimport { UnwrapRef, Ref } from './ref'\r\n\r\nexport const enum ReactiveFlags {\r\n  SKIP = '__v_skip',\r\n  IS_REACTIVE = '__v_isReactive',\r\n  IS_READONLY = '__v_isReadonly',\r\n  RAW = '__v_raw',\r\n  REACTIVE = '__v_reactive',\r\n  READONLY = '__v_readonly'\r\n}\r\n\r\ninterface Target {\r\n  [ReactiveFlags.SKIP]?: boolean\r\n  [ReactiveFlags.IS_REACTIVE]?: boolean\r\n  [ReactiveFlags.IS_READONLY]?: boolean\r\n  [ReactiveFlags.RAW]?: any\r\n  [ReactiveFlags.REACTIVE]?: any\r\n  [ReactiveFlags.READONLY]?: any\r\n}\r\n\r\nconst collectionTypes = new Set<Function>([Set, Map, WeakMap, WeakSet])\r\nconst isObservableType = /*#__PURE__*/ makeMap(\r\n  'Object,Array,Map,Set,WeakMap,WeakSet'\r\n)\r\n\r\nconst canObserve = (value: Target): boolean => {\r\n  return (\r\n    !value[ReactiveFlags.SKIP] &&\r\n    isObservableType(toRawType(value)) &&\r\n    Object.isExtensible(value)\r\n  )\r\n}\r\n\r\n// only unwrap nested ref\r\ntype UnwrapNestedRefs<T> = T extends Ref ? T : UnwrapRef<T>\r\n\r\nexport function reactive<T extends object>(target: T): UnwrapNestedRefs<T>\r\nexport function reactive(target: object) {\r\n  // if trying to observe a readonly proxy, return the readonly version.\r\n  if (target && (target as Target)[ReactiveFlags.IS_READONLY]) {\r\n    return target\r\n  }\r\n  return createReactiveObject(\r\n    target,\r\n    false,\r\n    mutableHandlers,\r\n    mutableCollectionHandlers\r\n  )\r\n}\r\n\r\n// Return a reactive-copy of the original object, where only the root level\r\n// properties are reactive, and does NOT unwrap refs nor recursively convert\r\n// returned properties.\r\nexport function shallowReactive<T extends object>(target: T): T {\r\n  return createReactiveObject(\r\n    target,\r\n    false,\r\n    shallowReactiveHandlers,\r\n    shallowCollectionHandlers\r\n  )\r\n}\r\n\r\ntype Primitive = string | number | boolean | bigint | symbol | undefined | null\r\ntype Builtin = Primitive | Function | Date | Error | RegExp\r\nexport type DeepReadonly<T> = T extends Builtin\r\n  ? T\r\n  : T extends Map<infer K, infer V>\r\n    ? ReadonlyMap<DeepReadonly<K>, DeepReadonly<V>>\r\n    : T extends ReadonlyMap<infer K, infer V>\r\n      ? ReadonlyMap<DeepReadonly<K>, DeepReadonly<V>>\r\n      : T extends WeakMap<infer K, infer V>\r\n        ? WeakMap<DeepReadonly<K>, DeepReadonly<V>>\r\n        : T extends Set<infer U>\r\n          ? ReadonlySet<DeepReadonly<U>>\r\n          : T extends ReadonlySet<infer U>\r\n            ? ReadonlySet<DeepReadonly<U>>\r\n            : T extends WeakSet<infer U>\r\n              ? WeakSet<DeepReadonly<U>>\r\n              : T extends Promise<infer U>\r\n                ? Promise<DeepReadonly<U>>\r\n                : T extends {}\r\n                  ? { readonly [K in keyof T]: DeepReadonly<T[K]> }\r\n                  : Readonly<T>\r\n\r\nexport function readonly<T extends object>(\r\n  target: T\r\n): DeepReadonly<UnwrapNestedRefs<T>> {\r\n  return createReactiveObject(\r\n    target,\r\n    true,\r\n    readonlyHandlers,\r\n    readonlyCollectionHandlers\r\n  )\r\n}\r\n\r\n// Return a reactive-copy of the original object, where only the root level\r\n// properties are readonly, and does NOT unwrap refs nor recursively convert\r\n// returned properties.\r\n// This is used for creating the props proxy object for stateful components.\r\nexport function shallowReadonly<T extends object>(\r\n  target: T\r\n): Readonly<{ [K in keyof T]: UnwrapNestedRefs<T[K]> }> {\r\n  return createReactiveObject(\r\n    target,\r\n    true,\r\n    shallowReadonlyHandlers,\r\n    readonlyCollectionHandlers\r\n  )\r\n}\r\n\r\nfunction createReactiveObject(\r\n  target: Target,\r\n  isReadonly: boolean,\r\n  baseHandlers: ProxyHandler<any>,\r\n  collectionHandlers: ProxyHandler<any>\r\n) {\r\n  if (!isObject(target)) {\r\n    if (__DEV__) {\r\n      console.warn(`value cannot be made reactive: ${String(target)}`)\r\n    }\r\n    return target\r\n  }\r\n  // target is already a Proxy, return it.\r\n  // exception: calling readonly() on a reactive object\r\n  if (\r\n    target[ReactiveFlags.RAW] &&\r\n    !(isReadonly && target[ReactiveFlags.IS_REACTIVE])\r\n  ) {\r\n    return target\r\n  }\r\n  // target already has corresponding Proxy\r\n  const reactiveFlag = isReadonly\r\n    ? ReactiveFlags.READONLY\r\n    : ReactiveFlags.REACTIVE\r\n  if (hasOwn(target, reactiveFlag)) {\r\n    return target[reactiveFlag]\r\n  }\r\n  // only a whitelist of value types can be observed.\r\n  if (!canObserve(target)) {\r\n    return target\r\n  }\r\n  const observed = new Proxy(\r\n    target,\r\n    collectionTypes.has(target.constructor) ? collectionHandlers : baseHandlers\r\n  )\r\n  def(target, reactiveFlag, observed)\r\n  return observed\r\n}\r\n\r\nexport function isReactive(value: unknown): boolean {\r\n  if (isReadonly(value)) {\r\n    return isReactive((value as Target)[ReactiveFlags.RAW])\r\n  }\r\n  return !!(value && (value as Target)[ReactiveFlags.IS_REACTIVE])\r\n}\r\n\r\nexport function isReadonly(value: unknown): boolean {\r\n  return !!(value && (value as Target)[ReactiveFlags.IS_READONLY])\r\n}\r\n\r\nexport function isProxy(value: unknown): boolean {\r\n  return isReactive(value) || isReadonly(value)\r\n}\r\n\r\nexport function toRaw<T>(observed: T): T {\r\n  return (\r\n    (observed && toRaw((observed as Target)[ReactiveFlags.RAW])) || observed\r\n  )\r\n}\r\n\r\nexport function markRaw<T extends object>(value: T): T {\r\n  def(value, ReactiveFlags.SKIP, true)\r\n  return value\r\n}\r\n","import { track, trigger } from './effect'\r\nimport { TrackOpTypes, TriggerOpTypes } from './operations'\r\nimport { isObject, hasChanged } from '@vue/shared'\r\nimport { reactive, isProxy, toRaw, isReactive } from './reactive'\r\nimport { CollectionTypes } from './collectionHandlers'\r\n\r\ndeclare const RefSymbol: unique symbol\r\n\r\nexport interface Ref<T = any> {\r\n  /**\r\n   * Type differentiator only.\r\n   * We need this to be in public d.ts but don't want it to show up in IDE\r\n   * autocomplete, so we use a private Symbol instead.\r\n   */\r\n  [RefSymbol]: true\r\n  value: T\r\n}\r\n\r\nexport type ToRefs<T = any> = { [K in keyof T]: Ref<T[K]> }\r\n\r\nconst convert = <T extends unknown>(val: T): T =>\r\n  isObject(val) ? reactive(val) : val\r\n\r\nexport function isRef<T>(r: Ref<T> | unknown): r is Ref<T>\r\nexport function isRef(r: any): r is Ref {\r\n  return r ? r.__v_isRef === true : false\r\n}\r\n\r\nexport function ref<T extends object>(\r\n  value: T\r\n): T extends Ref ? T : Ref<UnwrapRef<T>>\r\nexport function ref<T>(value: T): Ref<UnwrapRef<T>>\r\nexport function ref<T = any>(): Ref<T | undefined>\r\nexport function ref(value?: unknown) {\r\n  return createRef(value)\r\n}\r\n\r\nexport function shallowRef<T>(value: T): T extends Ref ? T : Ref<T>\r\nexport function shallowRef<T = any>(): Ref<T | undefined>\r\nexport function shallowRef(value?: unknown) {\r\n  return createRef(value, true)\r\n}\r\n\r\nfunction createRef(rawValue: unknown, shallow = false) {\r\n  if (isRef(rawValue)) {\r\n    return rawValue\r\n  }\r\n  let value = shallow ? rawValue : convert(rawValue)\r\n  const r = {\r\n    __v_isRef: true,\r\n    get value() {\r\n      track(r, TrackOpTypes.GET, 'value')\r\n      return value\r\n    },\r\n    set value(newVal) {\r\n      if (hasChanged(toRaw(newVal), rawValue)) {\r\n        rawValue = newVal\r\n        value = shallow ? newVal : convert(newVal)\r\n        trigger(r, TriggerOpTypes.SET, 'value', newVal)\r\n      }\r\n    }\r\n  }\r\n  return r\r\n}\r\n\r\nexport function triggerRef(ref: Ref) {\r\n  trigger(ref, TriggerOpTypes.SET, 'value', __DEV__ ? ref.value : void 0)\r\n}\r\n\r\nexport function unref<T>(ref: T): T extends Ref<infer V> ? V : T {\r\n  return isRef(ref) ? (ref.value as any) : ref\r\n}\r\n\r\nconst shallowUnwrapHandlers: ProxyHandler<any> = {\r\n  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\r\n  set: (target, key, value, receiver) => {\r\n    const oldValue = target[key]\r\n    if (isRef(oldValue) && !isRef(value)) {\r\n      oldValue.value = value\r\n      return true\r\n    } else {\r\n      return Reflect.set(target, key, value, receiver)\r\n    }\r\n  }\r\n}\r\n\r\nexport function proxyRefs<T extends object>(\r\n  objectWithRefs: T\r\n): ShallowUnwrapRef<T> {\r\n  return isReactive(objectWithRefs)\r\n    ? objectWithRefs\r\n    : new Proxy(objectWithRefs, shallowUnwrapHandlers)\r\n}\r\n\r\nexport type CustomRefFactory<T> = (\r\n  track: () => void,\r\n  trigger: () => void\r\n) => {\r\n  get: () => T\r\n  set: (value: T) => void\r\n}\r\n\r\nexport function customRef<T>(factory: CustomRefFactory<T>): Ref<T> {\r\n  const { get, set } = factory(\r\n    () => track(r, TrackOpTypes.GET, 'value'),\r\n    () => trigger(r, TriggerOpTypes.SET, 'value')\r\n  )\r\n  const r = {\r\n    __v_isRef: true,\r\n    get value() {\r\n      return get()\r\n    },\r\n    set value(v) {\r\n      set(v)\r\n    }\r\n  }\r\n  return r as any\r\n}\r\n\r\nexport function toRefs<T extends object>(object: T): ToRefs<T> {\r\n  if (__DEV__ && !isProxy(object)) {\r\n    console.warn(`toRefs() expects a reactive object but received a plain one.`)\r\n  }\r\n  const ret: any = {}\r\n  for (const key in object) {\r\n    ret[key] = toRef(object, key)\r\n  }\r\n  return ret\r\n}\r\n\r\nexport function toRef<T extends object, K extends keyof T>(\r\n  object: T,\r\n  key: K\r\n): Ref<T[K]> {\r\n  return {\r\n    __v_isRef: true,\r\n    get value(): any {\r\n      return object[key]\r\n    },\r\n    set value(newVal) {\r\n      object[key] = newVal\r\n    }\r\n  } as any\r\n}\r\n\r\n// corner case when use narrows type\r\n// Ex. type RelativePath = string & { __brand: unknown }\r\n// RelativePath extends object -> true\r\ntype BaseTypes = string | number | boolean\r\n\r\n/**\r\n * This is a special exported interface for other packages to declare\r\n * additional types that should bail out for ref unwrapping. For example\r\n * \\@vue/runtime-dom can declare it like so in its d.ts:\r\n *\r\n * ``` ts\r\n * declare module '@vue/reactivity' {\r\n *   export interface RefUnwrapBailTypes {\r\n *     runtimeDOMBailTypes: Node | Window\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * Note that api-extractor somehow refuses to include `declare module`\r\n * augmentations in its generated d.ts, so we have to manually append them\r\n * to the final generated d.ts in our build process.\r\n */\r\nexport interface RefUnwrapBailTypes {}\r\n\r\nexport type ShallowUnwrapRef<T> = {\r\n  [K in keyof T]: T[K] extends Ref<infer V> ? V : T[K]\r\n}\r\n\r\nexport type UnwrapRef<T> = T extends Ref<infer V>\r\n  ? UnwrapRefSimple<V>\r\n  : UnwrapRefSimple<T>\r\n\r\ntype UnwrapRefSimple<T> = T extends\r\n  | Function\r\n  | CollectionTypes\r\n  | BaseTypes\r\n  | Ref\r\n  | RefUnwrapBailTypes[keyof RefUnwrapBailTypes]\r\n  ? T\r\n  : T extends Array<any>\r\n    ? { [K in keyof T]: UnwrapRefSimple<T[K]> }\r\n    : T extends object ? UnwrappedObject<T> : T\r\n\r\n// Extract all known symbols from an object\r\n// when unwrapping Object the symbols are not `in keyof`, this should cover all the\r\n// known symbols\r\ntype SymbolExtract<T> = (T extends { [Symbol.asyncIterator]: infer V }\r\n  ? { [Symbol.asyncIterator]: V }\r\n  : {}) &\r\n  (T extends { [Symbol.hasInstance]: infer V }\r\n    ? { [Symbol.hasInstance]: V }\r\n    : {}) &\r\n  (T extends { [Symbol.isConcatSpreadable]: infer V }\r\n    ? { [Symbol.isConcatSpreadable]: V }\r\n    : {}) &\r\n  (T extends { [Symbol.iterator]: infer V } ? { [Symbol.iterator]: V } : {}) &\r\n  (T extends { [Symbol.match]: infer V } ? { [Symbol.match]: V } : {}) &\r\n  (T extends { [Symbol.matchAll]: infer V } ? { [Symbol.matchAll]: V } : {}) &\r\n  (T extends { [Symbol.replace]: infer V } ? { [Symbol.replace]: V } : {}) &\r\n  (T extends { [Symbol.search]: infer V } ? { [Symbol.search]: V } : {}) &\r\n  (T extends { [Symbol.species]: infer V } ? { [Symbol.species]: V } : {}) &\r\n  (T extends { [Symbol.split]: infer V } ? { [Symbol.split]: V } : {}) &\r\n  (T extends { [Symbol.toPrimitive]: infer V }\r\n    ? { [Symbol.toPrimitive]: V }\r\n    : {}) &\r\n  (T extends { [Symbol.toStringTag]: infer V }\r\n    ? { [Symbol.toStringTag]: V }\r\n    : {}) &\r\n  (T extends { [Symbol.unscopables]: infer V }\r\n    ? { [Symbol.unscopables]: V }\r\n    : {})\r\n\r\ntype UnwrappedObject<T> = { [P in keyof T]: UnwrapRef<T[P]> } & SymbolExtract<T>\r\n","import { effect, ReactiveEffect, trigger, track } from './effect'\r\nimport { TriggerOpTypes, TrackOpTypes } from './operations'\r\nimport { Ref } from './ref'\r\nimport { isFunction, NOOP } from '@vue/shared'\r\nimport { ReactiveFlags } from './reactive'\r\n\r\nexport interface ComputedRef<T = any> extends WritableComputedRef<T> {\r\n  readonly value: T\r\n}\r\n\r\nexport interface WritableComputedRef<T> extends Ref<T> {\r\n  readonly effect: ReactiveEffect<T>\r\n}\r\n\r\nexport type ComputedGetter<T> = (ctx?: any) => T\r\nexport type ComputedSetter<T> = (v: T) => void\r\n\r\nexport interface WritableComputedOptions<T> {\r\n  get: ComputedGetter<T>\r\n  set: ComputedSetter<T>\r\n}\r\n\r\nexport function computed<T>(getter: ComputedGetter<T>): ComputedRef<T>\r\nexport function computed<T>(\r\n  options: WritableComputedOptions<T>\r\n): WritableComputedRef<T>\r\nexport function computed<T>(\r\n  getterOrOptions: ComputedGetter<T> | WritableComputedOptions<T>\r\n) {\r\n  let getter: ComputedGetter<T>\r\n  let setter: ComputedSetter<T>\r\n\r\n  if (isFunction(getterOrOptions)) {\r\n    getter = getterOrOptions\r\n    setter = __DEV__\r\n      ? () => {\r\n          console.warn('Write operation failed: computed value is readonly')\r\n        }\r\n      : NOOP\r\n  } else {\r\n    getter = getterOrOptions.get\r\n    setter = getterOrOptions.set\r\n  }\r\n\r\n  let dirty = true\r\n  let value: T\r\n  let computed: ComputedRef<T>\r\n\r\n  const runner = effect(getter, {\r\n    lazy: true,\r\n    scheduler: () => {\r\n      if (!dirty) {\r\n        dirty = true\r\n        trigger(computed, TriggerOpTypes.SET, 'value')\r\n      }\r\n    }\r\n  })\r\n  computed = {\r\n    __v_isRef: true,\r\n    [ReactiveFlags.IS_READONLY]:\r\n      isFunction(getterOrOptions) || !getterOrOptions.set,\r\n\r\n    // expose effect so computed can be stopped\r\n    effect: runner,\r\n    get value() {\r\n      if (dirty) {\r\n        value = runner()\r\n        dirty = false\r\n      }\r\n      track(computed, TrackOpTypes.GET, 'value')\r\n      return value\r\n    },\r\n    set value(newValue: T) {\r\n      setter(newValue)\r\n    }\r\n  } as any\r\n  return computed\r\n}\r\n"],"names":["get","has","set"],"mappings":"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"}
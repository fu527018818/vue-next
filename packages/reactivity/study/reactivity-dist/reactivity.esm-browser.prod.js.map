{"version":3,"file":"reactivity.esm-browser.prod.js","sources":["../../shared/src/makeMap.ts","../../shared/src/index.ts","../src/effect.ts","../src/baseHandlers.ts","../src/collectionHandlers.ts","../src/reactive.ts","../src/ref.ts","../src/computed.ts"],"sourcesContent":["/**\r\n * Make a map and return a function for checking if a key\r\n * is in that map.\r\n * IMPORTANT: all calls of this function must be prefixed with\r\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\r\n * So that rollup can tree-shake them if necessary.\r\n */\r\nexport function makeMap(\r\n  str: string,\r\n  expectsLowerCase?: boolean\r\n): (key: string) => boolean {\r\n  const map: Record<string, boolean> = Object.create(null)\r\n  const list: Array<string> = str.split(',')\r\n  for (let i = 0; i < list.length; i++) {\r\n    map[list[i]] = true\r\n  }\r\n  return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val]\r\n}\r\n","import { makeMap } from './makeMap'\r\n\r\nexport { makeMap }\r\nexport * from './patchFlags'\r\nexport * from './shapeFlags'\r\nexport * from './slotFlags'\r\nexport * from './globalsWhitelist'\r\nexport * from './codeframe'\r\nexport * from './normalizeProp'\r\nexport * from './domTagConfig'\r\nexport * from './domAttrConfig'\r\nexport * from './escapeHtml'\r\nexport * from './looseEqual'\r\nexport * from './toDisplayString'\r\n\r\n/**\r\n * List of @babel/parser plugins that are used for template expression\r\n * transforms and SFC script transforms. By default we enable proposals slated\r\n * for ES2020. This will need to be updated as the spec moves forward.\r\n * Full list at https://babeljs.io/docs/en/next/babel-parser#plugins\r\n */\r\nexport const babelParserDefautPlugins = [\r\n  'bigInt',\r\n  'optionalChaining',\r\n  'nullishCoalescingOperator'\r\n] as const\r\n\r\nexport const EMPTY_OBJ: { readonly [key: string]: any } = __DEV__\r\n  ? Object.freeze({})\r\n  : {}\r\nexport const EMPTY_ARR: [] = []\r\n\r\nexport const NOOP = () => {}\r\n\r\n/**\r\n * Always return false.\r\n */\r\nexport const NO = () => false\r\n\r\nconst onRE = /^on[^a-z]/\r\nexport const isOn = (key: string) => onRE.test(key)\r\n\r\nexport const isModelListener = (key: string) => key.startsWith('onUpdate:')\r\n\r\nexport const extend = Object.assign\r\n\r\nexport const remove = <T>(arr: T[], el: T) => {\r\n  const i = arr.indexOf(el)\r\n  if (i > -1) {\r\n    arr.splice(i, 1)\r\n  }\r\n}\r\n\r\nconst hasOwnProperty = Object.prototype.hasOwnProperty\r\nexport const hasOwn = (\r\n  val: object,\r\n  key: string | symbol\r\n): key is keyof typeof val => hasOwnProperty.call(val, key)\r\n\r\nexport const isArray = Array.isArray\r\nexport const isDate = (val: unknown): val is Date => val instanceof Date\r\nexport const isFunction = (val: unknown): val is Function =>\r\n  typeof val === 'function'\r\nexport const isString = (val: unknown): val is string => typeof val === 'string'\r\nexport const isSymbol = (val: unknown): val is symbol => typeof val === 'symbol'\r\nexport const isObject = (val: unknown): val is Record<any, any> =>\r\n  val !== null && typeof val === 'object'\r\n\r\nexport const isPromise = <T = any>(val: unknown): val is Promise<T> => {\r\n  return isObject(val) && isFunction(val.then) && isFunction(val.catch)\r\n}\r\n\r\nexport const objectToString = Object.prototype.toString\r\nexport const toTypeString = (value: unknown): string =>\r\n  objectToString.call(value)\r\n\r\nexport const toRawType = (value: unknown): string => {\r\n  return toTypeString(value).slice(8, -1)\r\n}\r\n\r\nexport const isPlainObject = (val: unknown): val is object =>\r\n  toTypeString(val) === '[object Object]'\r\n\r\nexport const isReservedProp = /*#__PURE__*/ makeMap(\r\n  'key,ref,' +\r\n    'onVnodeBeforeMount,onVnodeMounted,' +\r\n    'onVnodeBeforeUpdate,onVnodeUpdated,' +\r\n    'onVnodeBeforeUnmount,onVnodeUnmounted'\r\n)\r\n\r\nconst cacheStringFunction = <T extends (str: string) => string>(fn: T): T => {\r\n  const cache: Record<string, string> = Object.create(null)\r\n  return ((str: string) => {\r\n    const hit = cache[str]\r\n    return hit || (cache[str] = fn(str))\r\n  }) as any\r\n}\r\n\r\nconst camelizeRE = /-(\\w)/g\r\n/**\r\n * @private\r\n */\r\nexport const camelize = cacheStringFunction(\r\n  (str: string): string => {\r\n    return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''))\r\n  }\r\n)\r\n\r\nconst hyphenateRE = /\\B([A-Z])/g\r\n/**\r\n * @private\r\n */\r\nexport const hyphenate = cacheStringFunction(\r\n  (str: string): string => {\r\n    return str.replace(hyphenateRE, '-$1').toLowerCase()\r\n  }\r\n)\r\n\r\n/**\r\n * @private\r\n */\r\nexport const capitalize = cacheStringFunction(\r\n  (str: string): string => {\r\n    return str.charAt(0).toUpperCase() + str.slice(1)\r\n  }\r\n)\r\n\r\n// compare whether a value has changed, accounting for NaN.\r\nexport const hasChanged = (value: any, oldValue: any): boolean =>\r\n  value !== oldValue && (value === value || oldValue === oldValue)\r\n\r\nexport const invokeArrayFns = (fns: Function[], arg?: any) => {\r\n  for (let i = 0; i < fns.length; i++) {\r\n    fns[i](arg)\r\n  }\r\n}\r\n\r\nexport const def = (obj: object, key: string | symbol, value: any) => {\r\n  Object.defineProperty(obj, key, {\r\n    configurable: true,\r\n    enumerable: false,\r\n    value\r\n  })\r\n}\r\n\r\nexport const toNumber = (val: any): any => {\r\n  const n = parseFloat(val)\r\n  return isNaN(n) ? val : n\r\n}\r\n\r\nlet _globalThis: any\r\nexport const getGlobalThis = (): any => {\r\n  return (\r\n    _globalThis ||\r\n    (_globalThis =\r\n      typeof globalThis !== 'undefined'\r\n        ? globalThis\r\n        : typeof self !== 'undefined'\r\n          ? self\r\n          : typeof window !== 'undefined'\r\n            ? window\r\n            : typeof global !== 'undefined'\r\n              ? global\r\n              : {})\r\n  )\r\n}\r\n","import { TrackOpTypes, TriggerOpTypes } from './operations'\r\nimport { EMPTY_OBJ, isArray } from '@vue/shared'\r\n\r\n// The main WeakMap that stores {target -> key -> dep} connections.\r\n// Conceptually, it's easier to think of a dependency as a Dep class\r\n// which maintains a Set of subscribers, but we simply store them as\r\n// raw Sets to reduce memory overhead.\r\ntype Dep = Set<ReactiveEffect>\r\ntype KeyToDepMap = Map<any, Dep>\r\nconst targetMap = new WeakMap<any, KeyToDepMap>()\r\n\r\nexport interface ReactiveEffect<T = any> {\r\n  (): T\r\n  _isEffect: true\r\n  id: number\r\n  active: boolean\r\n  raw: () => T\r\n  deps: Array<Dep>\r\n  options: ReactiveEffectOptions\r\n}\r\n\r\nexport interface ReactiveEffectOptions {\r\n  lazy?: boolean\r\n  scheduler?: (job: ReactiveEffect) => void\r\n  onTrack?: (event: DebuggerEvent) => void\r\n  onTrigger?: (event: DebuggerEvent) => void\r\n  onStop?: () => void\r\n}\r\n\r\nexport type DebuggerEvent = {\r\n  effect: ReactiveEffect\r\n  target: object\r\n  type: TrackOpTypes | TriggerOpTypes\r\n  key: any\r\n} & DebuggerEventExtraInfo\r\n\r\nexport interface DebuggerEventExtraInfo {\r\n  newValue?: any\r\n  oldValue?: any\r\n  oldTarget?: Map<any, any> | Set<any>\r\n}\r\n\r\nconst effectStack: ReactiveEffect[] = []\r\nlet activeEffect: ReactiveEffect | undefined\r\n\r\nexport const ITERATE_KEY = Symbol(__DEV__ ? 'iterate' : '')\r\nexport const MAP_KEY_ITERATE_KEY = Symbol(__DEV__ ? 'Map key iterate' : '')\r\n\r\nexport function isEffect(fn: any): fn is ReactiveEffect {\r\n  return fn && fn._isEffect === true\r\n}\r\n\r\nexport function effect<T = any>(\r\n  fn: () => T,\r\n  options: ReactiveEffectOptions = EMPTY_OBJ\r\n): ReactiveEffect<T> {\r\n  if (isEffect(fn)) {\r\n    fn = fn.raw\r\n  }\r\n  const effect = createReactiveEffect(fn, options)\r\n  if (!options.lazy) {\r\n    effect()\r\n  }\r\n  return effect\r\n}\r\n\r\nexport function stop(effect: ReactiveEffect) {\r\n  if (effect.active) {\r\n    cleanup(effect)\r\n    if (effect.options.onStop) {\r\n      effect.options.onStop()\r\n    }\r\n    effect.active = false\r\n  }\r\n}\r\n\r\nlet uid = 0\r\n\r\nfunction createReactiveEffect<T = any>(\r\n  fn: () => T,\r\n  options: ReactiveEffectOptions\r\n): ReactiveEffect<T> {\r\n  const effect = function reactiveEffect(): unknown {\r\n    if (!effect.active) {\r\n      return options.scheduler ? undefined : fn()\r\n    }\r\n    if (!effectStack.includes(effect)) {\r\n      cleanup(effect)\r\n      try {\r\n        enableTracking()\r\n        effectStack.push(effect)\r\n        activeEffect = effect\r\n        return fn()\r\n      } finally {\r\n        effectStack.pop()\r\n        resetTracking()\r\n        activeEffect = effectStack[effectStack.length - 1]\r\n      }\r\n    }\r\n  } as ReactiveEffect\r\n  effect.id = uid++\r\n  effect._isEffect = true\r\n  effect.active = true\r\n  effect.raw = fn\r\n  effect.deps = []\r\n  effect.options = options\r\n  return effect\r\n}\r\n\r\nfunction cleanup(effect: ReactiveEffect) {\r\n  const { deps } = effect\r\n  if (deps.length) {\r\n    for (let i = 0; i < deps.length; i++) {\r\n      deps[i].delete(effect)\r\n    }\r\n    deps.length = 0\r\n  }\r\n}\r\n\r\nlet shouldTrack = true\r\nconst trackStack: boolean[] = []\r\n\r\nexport function pauseTracking() {\r\n  trackStack.push(shouldTrack)\r\n  shouldTrack = false\r\n}\r\n\r\nexport function enableTracking() {\r\n  trackStack.push(shouldTrack)\r\n  shouldTrack = true\r\n}\r\n\r\nexport function resetTracking() {\r\n  const last = trackStack.pop()\r\n  shouldTrack = last === undefined ? true : last\r\n}\r\n\r\nexport function track(target: object, type: TrackOpTypes, key: unknown) {\r\n  if (!shouldTrack || activeEffect === undefined) {\r\n    return\r\n  }\r\n  let depsMap = targetMap.get(target)\r\n  if (!depsMap) {\r\n    targetMap.set(target, (depsMap = new Map()))\r\n  }\r\n  let dep = depsMap.get(key)\r\n  if (!dep) {\r\n    depsMap.set(key, (dep = new Set()))\r\n  }\r\n  if (!dep.has(activeEffect)) {\r\n    dep.add(activeEffect)\r\n    activeEffect.deps.push(dep)\r\n    if (__DEV__ && activeEffect.options.onTrack) {\r\n      activeEffect.options.onTrack({\r\n        effect: activeEffect,\r\n        target,\r\n        type,\r\n        key\r\n      })\r\n    }\r\n  }\r\n}\r\n\r\nexport function trigger(\r\n  target: object,\r\n  type: TriggerOpTypes,\r\n  key?: unknown,\r\n  newValue?: unknown,\r\n  oldValue?: unknown,\r\n  oldTarget?: Map<unknown, unknown> | Set<unknown>\r\n) {\r\n  const depsMap = targetMap.get(target)\r\n  if (!depsMap) {\r\n    // never been tracked\r\n    return\r\n  }\r\n\r\n  const effects = new Set<ReactiveEffect>()\r\n  const add = (effectsToAdd: Set<ReactiveEffect> | undefined) => {\r\n    if (effectsToAdd) {\r\n      effectsToAdd.forEach(effect => effects.add(effect))\r\n    }\r\n  }\r\n\r\n  if (type === TriggerOpTypes.CLEAR) {\r\n    // collection being cleared\r\n    // trigger all effects for target\r\n    depsMap.forEach(add)\r\n  } else if (key === 'length' && isArray(target)) {\r\n    depsMap.forEach((dep, key) => {\r\n      if (key === 'length' || key >= (newValue as number)) {\r\n        add(dep)\r\n      }\r\n    })\r\n  } else {\r\n    // schedule runs for SET | ADD | DELETE\r\n    if (key !== void 0) {\r\n      add(depsMap.get(key))\r\n    }\r\n    // also run for iteration key on ADD | DELETE | Map.SET\r\n    const isAddOrDelete =\r\n      type === TriggerOpTypes.ADD ||\r\n      (type === TriggerOpTypes.DELETE && !isArray(target))\r\n    if (\r\n      isAddOrDelete ||\r\n      (type === TriggerOpTypes.SET && target instanceof Map)\r\n    ) {\r\n      add(depsMap.get(isArray(target) ? 'length' : ITERATE_KEY))\r\n    }\r\n    if (isAddOrDelete && target instanceof Map) {\r\n      add(depsMap.get(MAP_KEY_ITERATE_KEY))\r\n    }\r\n  }\r\n\r\n  const run = (effect: ReactiveEffect) => {\r\n    if (__DEV__ && effect.options.onTrigger) {\r\n      effect.options.onTrigger({\r\n        effect,\r\n        target,\r\n        key,\r\n        type,\r\n        newValue,\r\n        oldValue,\r\n        oldTarget\r\n      })\r\n    }\r\n    if (effect.options.scheduler) {\r\n      effect.options.scheduler(effect)\r\n    } else {\r\n      effect()\r\n    }\r\n  }\r\n\r\n  effects.forEach(run)\r\n}\r\n","import { reactive, readonly, toRaw, ReactiveFlags } from './reactive'\r\nimport { TrackOpTypes, TriggerOpTypes } from './operations'\r\nimport { track, trigger, ITERATE_KEY } from './effect'\r\nimport {\r\n  isObject,\r\n  hasOwn,\r\n  isSymbol,\r\n  hasChanged,\r\n  isArray,\r\n  extend\r\n} from '@vue/shared'\r\nimport { isRef } from './ref'\r\n\r\nconst builtInSymbols = new Set(\r\n  Object.getOwnPropertyNames(Symbol)\r\n    .map(key => (Symbol as any)[key])\r\n    .filter(isSymbol)\r\n)\r\n\r\nconst get = /*#__PURE__*/ createGetter()\r\nconst shallowGet = /*#__PURE__*/ createGetter(false, true)\r\nconst readonlyGet = /*#__PURE__*/ createGetter(true)\r\nconst shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true)\r\n\r\nconst arrayInstrumentations: Record<string, Function> = {}\r\n;['includes', 'indexOf', 'lastIndexOf'].forEach(key => {\r\n  arrayInstrumentations[key] = function(...args: any[]): any {\r\n    const arr = toRaw(this) as any\r\n    for (let i = 0, l = (this as any).length; i < l; i++) {\r\n      track(arr, TrackOpTypes.GET, i + '')\r\n    }\r\n    // we run the method using the original args first (which may be reactive)\r\n    const res = arr[key](...args)\r\n    if (res === -1 || res === false) {\r\n      // if that didn't work, run it again using raw values.\r\n      return arr[key](...args.map(toRaw))\r\n    } else {\r\n      return res\r\n    }\r\n  }\r\n})\r\n\r\nfunction createGetter(isReadonly = false, shallow = false) {\r\n  return function get(target: object, key: string | symbol, receiver: object) {\r\n    if (key === ReactiveFlags.IS_REACTIVE) {\r\n      return !isReadonly\r\n    } else if (key === ReactiveFlags.IS_READONLY) {\r\n      return isReadonly\r\n    } else if (\r\n      key === ReactiveFlags.RAW &&\r\n      receiver ===\r\n        (isReadonly\r\n          ? (target as any)[ReactiveFlags.READONLY]\r\n          : (target as any)[ReactiveFlags.REACTIVE])\r\n    ) {\r\n      return target\r\n    }\r\n\r\n    const targetIsArray = isArray(target)\r\n    if (targetIsArray && hasOwn(arrayInstrumentations, key)) {\r\n      return Reflect.get(arrayInstrumentations, key, receiver)\r\n    }\r\n\r\n    const res = Reflect.get(target, key, receiver)\r\n\r\n    if (\r\n      isSymbol(key)\r\n        ? builtInSymbols.has(key)\r\n        : key === `__proto__` || key === `__v_isRef`\r\n    ) {\r\n      return res\r\n    }\r\n\r\n    if (!isReadonly) {\r\n      track(target, TrackOpTypes.GET, key)\r\n    }\r\n\r\n    if (shallow) {\r\n      return res\r\n    }\r\n\r\n    if (isRef(res)) {\r\n      // ref unwrapping, only for Objects, not for Arrays.\r\n      return targetIsArray ? res : res.value\r\n    }\r\n\r\n    if (isObject(res)) {\r\n      // Convert returned value into a proxy as well. we do the isObject check\r\n      // here to avoid invalid value warning. Also need to lazy access readonly\r\n      // and reactive here to avoid circular dependency.\r\n      return isReadonly ? readonly(res) : reactive(res)\r\n    }\r\n\r\n    return res\r\n  }\r\n}\r\n\r\nconst set = /*#__PURE__*/ createSetter()\r\nconst shallowSet = /*#__PURE__*/ createSetter(true)\r\n\r\nfunction createSetter(shallow = false) {\r\n  return function set(\r\n    target: object,\r\n    key: string | symbol,\r\n    value: unknown,\r\n    receiver: object\r\n  ): boolean {\r\n    const oldValue = (target as any)[key]\r\n    if (!shallow) {\r\n      value = toRaw(value)\r\n      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\r\n        oldValue.value = value\r\n        return true\r\n      }\r\n    } else {\r\n      // in shallow mode, objects are set as-is regardless of reactive or not\r\n    }\r\n\r\n    const hadKey = hasOwn(target, key)\r\n    const result = Reflect.set(target, key, value, receiver)\r\n    // don't trigger if target is something up in the prototype chain of original\r\n    if (target === toRaw(receiver)) {\r\n      if (!hadKey) {\r\n        trigger(target, TriggerOpTypes.ADD, key, value)\r\n      } else if (hasChanged(value, oldValue)) {\r\n        trigger(target, TriggerOpTypes.SET, key, value, oldValue)\r\n      }\r\n    }\r\n    return result\r\n  }\r\n}\r\n\r\nfunction deleteProperty(target: object, key: string | symbol): boolean {\r\n  const hadKey = hasOwn(target, key)\r\n  const oldValue = (target as any)[key]\r\n  const result = Reflect.deleteProperty(target, key)\r\n  if (result && hadKey) {\r\n    trigger(target, TriggerOpTypes.DELETE, key, undefined, oldValue)\r\n  }\r\n  return result\r\n}\r\n\r\nfunction has(target: object, key: string | symbol): boolean {\r\n  const result = Reflect.has(target, key)\r\n  if (!isSymbol(key) || !builtInSymbols.has(key)) {\r\n    track(target, TrackOpTypes.HAS, key)\r\n  }\r\n  return result\r\n}\r\n\r\nfunction ownKeys(target: object): (string | number | symbol)[] {\r\n  track(target, TrackOpTypes.ITERATE, ITERATE_KEY)\r\n  return Reflect.ownKeys(target)\r\n}\r\n\r\nexport const mutableHandlers: ProxyHandler<object> = {\r\n  get,\r\n  set,\r\n  deleteProperty,\r\n  has,\r\n  ownKeys\r\n}\r\n\r\nexport const readonlyHandlers: ProxyHandler<object> = {\r\n  get: readonlyGet,\r\n  has,\r\n  ownKeys,\r\n  set(target, key) {\r\n    if (__DEV__) {\r\n      console.warn(\r\n        `Set operation on key \"${String(key)}\" failed: target is readonly.`,\r\n        target\r\n      )\r\n    }\r\n    return true\r\n  },\r\n  deleteProperty(target, key) {\r\n    if (__DEV__) {\r\n      console.warn(\r\n        `Delete operation on key \"${String(key)}\" failed: target is readonly.`,\r\n        target\r\n      )\r\n    }\r\n    return true\r\n  }\r\n}\r\n\r\nexport const shallowReactiveHandlers: ProxyHandler<object> = extend(\r\n  {},\r\n  mutableHandlers,\r\n  {\r\n    get: shallowGet,\r\n    set: shallowSet\r\n  }\r\n)\r\n\r\n// Props handlers are special in the sense that it should not unwrap top-level\r\n// refs (in order to allow refs to be explicitly passed down), but should\r\n// retain the reactivity of the normal readonly object.\r\nexport const shallowReadonlyHandlers: ProxyHandler<object> = extend(\r\n  {},\r\n  readonlyHandlers,\r\n  {\r\n    get: shallowReadonlyGet\r\n  }\r\n)\r\n","import { toRaw, reactive, readonly, ReactiveFlags } from './reactive'\r\nimport { track, trigger, ITERATE_KEY, MAP_KEY_ITERATE_KEY } from './effect'\r\nimport { TrackOpTypes, TriggerOpTypes } from './operations'\r\nimport {\r\n  isObject,\r\n  capitalize,\r\n  hasOwn,\r\n  hasChanged,\r\n  toRawType\r\n} from '@vue/shared'\r\n\r\nexport type CollectionTypes = IterableCollections | WeakCollections\r\n\r\ntype IterableCollections = Map<any, any> | Set<any>\r\ntype WeakCollections = WeakMap<any, any> | WeakSet<any>\r\ntype MapTypes = Map<any, any> | WeakMap<any, any>\r\ntype SetTypes = Set<any> | WeakSet<any>\r\n\r\nconst toReactive = <T extends unknown>(value: T): T =>\r\n  isObject(value) ? reactive(value) : value\r\n\r\nconst toReadonly = <T extends unknown>(value: T): T =>\r\n  isObject(value) ? readonly(value) : value\r\n\r\nconst toShallow = <T extends unknown>(value: T): T => value\r\n\r\nconst getProto = <T extends CollectionTypes>(v: T): any =>\r\n  Reflect.getPrototypeOf(v)\r\n\r\nfunction get(\r\n  target: MapTypes,\r\n  key: unknown,\r\n  wrap: typeof toReactive | typeof toReadonly | typeof toShallow\r\n) {\r\n  target = toRaw(target)\r\n  const rawKey = toRaw(key)\r\n  if (key !== rawKey) {\r\n    track(target, TrackOpTypes.GET, key)\r\n  }\r\n  track(target, TrackOpTypes.GET, rawKey)\r\n  const { has, get } = getProto(target)\r\n  if (has.call(target, key)) {\r\n    return wrap(get.call(target, key))\r\n  } else if (has.call(target, rawKey)) {\r\n    return wrap(get.call(target, rawKey))\r\n  }\r\n}\r\n\r\nfunction has(this: CollectionTypes, key: unknown): boolean {\r\n  const target = toRaw(this)\r\n  const rawKey = toRaw(key)\r\n  if (key !== rawKey) {\r\n    track(target, TrackOpTypes.HAS, key)\r\n  }\r\n  track(target, TrackOpTypes.HAS, rawKey)\r\n  const has = getProto(target).has\r\n  return has.call(target, key) || has.call(target, rawKey)\r\n}\r\n\r\nfunction size(target: IterableCollections) {\r\n  target = toRaw(target)\r\n  track(target, TrackOpTypes.ITERATE, ITERATE_KEY)\r\n  return Reflect.get(getProto(target), 'size', target)\r\n}\r\n\r\nfunction add(this: SetTypes, value: unknown) {\r\n  value = toRaw(value)\r\n  const target = toRaw(this)\r\n  const proto = getProto(target)\r\n  const hadKey = proto.has.call(target, value)\r\n  const result = proto.add.call(target, value)\r\n  if (!hadKey) {\r\n    trigger(target, TriggerOpTypes.ADD, value, value)\r\n  }\r\n  return result\r\n}\r\n\r\nfunction set(this: MapTypes, key: unknown, value: unknown) {\r\n  value = toRaw(value)\r\n  const target = toRaw(this)\r\n  const { has, get, set } = getProto(target)\r\n\r\n  let hadKey = has.call(target, key)\r\n  if (!hadKey) {\r\n    key = toRaw(key)\r\n    hadKey = has.call(target, key)\r\n  } else if (__DEV__) {\r\n    checkIdentityKeys(target, has, key)\r\n  }\r\n\r\n  const oldValue = get.call(target, key)\r\n  const result = set.call(target, key, value)\r\n  if (!hadKey) {\r\n    trigger(target, TriggerOpTypes.ADD, key, value)\r\n  } else if (hasChanged(value, oldValue)) {\r\n    trigger(target, TriggerOpTypes.SET, key, value, oldValue)\r\n  }\r\n  return result\r\n}\r\n\r\nfunction deleteEntry(this: CollectionTypes, key: unknown) {\r\n  const target = toRaw(this)\r\n  const { has, get, delete: del } = getProto(target)\r\n  let hadKey = has.call(target, key)\r\n  if (!hadKey) {\r\n    key = toRaw(key)\r\n    hadKey = has.call(target, key)\r\n  } else if (__DEV__) {\r\n    checkIdentityKeys(target, has, key)\r\n  }\r\n\r\n  const oldValue = get ? get.call(target, key) : undefined\r\n  // forward the operation before queueing reactions\r\n  const result = del.call(target, key)\r\n  if (hadKey) {\r\n    trigger(target, TriggerOpTypes.DELETE, key, undefined, oldValue)\r\n  }\r\n  return result\r\n}\r\n\r\nfunction clear(this: IterableCollections) {\r\n  const target = toRaw(this)\r\n  const hadItems = target.size !== 0\r\n  const oldTarget = __DEV__\r\n    ? target instanceof Map\r\n      ? new Map(target)\r\n      : new Set(target)\r\n    : undefined\r\n  // forward the operation before queueing reactions\r\n  const result = getProto(target).clear.call(target)\r\n  if (hadItems) {\r\n    trigger(target, TriggerOpTypes.CLEAR, undefined, undefined, oldTarget)\r\n  }\r\n  return result\r\n}\r\n\r\nfunction createForEach(isReadonly: boolean, shallow: boolean) {\r\n  return function forEach(\r\n    this: IterableCollections,\r\n    callback: Function,\r\n    thisArg?: unknown\r\n  ) {\r\n    const observed = this\r\n    const target = toRaw(observed)\r\n    const wrap = isReadonly ? toReadonly : shallow ? toShallow : toReactive\r\n    !isReadonly && track(target, TrackOpTypes.ITERATE, ITERATE_KEY)\r\n    // important: create sure the callback is\r\n    // 1. invoked with the reactive map as `this` and 3rd arg\r\n    // 2. the value received should be a corresponding reactive/readonly.\r\n    function wrappedCallback(value: unknown, key: unknown) {\r\n      return callback.call(thisArg, wrap(value), wrap(key), observed)\r\n    }\r\n    return getProto(target).forEach.call(target, wrappedCallback)\r\n  }\r\n}\r\n\r\ninterface Iterable {\r\n  [Symbol.iterator](): Iterator\r\n}\r\n\r\ninterface Iterator {\r\n  next(value?: any): IterationResult\r\n}\r\n\r\ninterface IterationResult {\r\n  value: any\r\n  done: boolean\r\n}\r\n\r\nfunction createIterableMethod(\r\n  method: string | symbol,\r\n  isReadonly: boolean,\r\n  shallow: boolean\r\n) {\r\n  return function(\r\n    this: IterableCollections,\r\n    ...args: unknown[]\r\n  ): Iterable & Iterator {\r\n    const target = toRaw(this)\r\n    const isMap = target instanceof Map\r\n    const isPair = method === 'entries' || (method === Symbol.iterator && isMap)\r\n    const isKeyOnly = method === 'keys' && isMap\r\n    const innerIterator = getProto(target)[method].apply(target, args)\r\n    const wrap = isReadonly ? toReadonly : shallow ? toShallow : toReactive\r\n    !isReadonly &&\r\n      track(\r\n        target,\r\n        TrackOpTypes.ITERATE,\r\n        isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY\r\n      )\r\n    // return a wrapped iterator which returns observed versions of the\r\n    // values emitted from the real iterator\r\n    return {\r\n      // iterator protocol\r\n      next() {\r\n        const { value, done } = innerIterator.next()\r\n        return done\r\n          ? { value, done }\r\n          : {\r\n              value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\r\n              done\r\n            }\r\n      },\r\n      // iterable protocol\r\n      [Symbol.iterator]() {\r\n        return this\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction createReadonlyMethod(type: TriggerOpTypes): Function {\r\n  return function(this: CollectionTypes, ...args: unknown[]) {\r\n    if (__DEV__) {\r\n      const key = args[0] ? `on key \"${args[0]}\" ` : ``\r\n      console.warn(\r\n        `${capitalize(type)} operation ${key}failed: target is readonly.`,\r\n        toRaw(this)\r\n      )\r\n    }\r\n    return type === TriggerOpTypes.DELETE ? false : this\r\n  }\r\n}\r\n\r\nconst mutableInstrumentations: Record<string, Function> = {\r\n  get(this: MapTypes, key: unknown) {\r\n    return get(this, key, toReactive)\r\n  },\r\n  get size() {\r\n    return size((this as unknown) as IterableCollections)\r\n  },\r\n  has,\r\n  add,\r\n  set,\r\n  delete: deleteEntry,\r\n  clear,\r\n  forEach: createForEach(false, false)\r\n}\r\n\r\nconst shallowInstrumentations: Record<string, Function> = {\r\n  get(this: MapTypes, key: unknown) {\r\n    return get(this, key, toShallow)\r\n  },\r\n  get size() {\r\n    return size((this as unknown) as IterableCollections)\r\n  },\r\n  has,\r\n  add,\r\n  set,\r\n  delete: deleteEntry,\r\n  clear,\r\n  forEach: createForEach(false, true)\r\n}\r\n\r\nconst readonlyInstrumentations: Record<string, Function> = {\r\n  get(this: MapTypes, key: unknown) {\r\n    return get(this, key, toReadonly)\r\n  },\r\n  get size() {\r\n    return size((this as unknown) as IterableCollections)\r\n  },\r\n  has,\r\n  add: createReadonlyMethod(TriggerOpTypes.ADD),\r\n  set: createReadonlyMethod(TriggerOpTypes.SET),\r\n  delete: createReadonlyMethod(TriggerOpTypes.DELETE),\r\n  clear: createReadonlyMethod(TriggerOpTypes.CLEAR),\r\n  forEach: createForEach(true, false)\r\n}\r\n\r\nconst iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator]\r\niteratorMethods.forEach(method => {\r\n  mutableInstrumentations[method as string] = createIterableMethod(\r\n    method,\r\n    false,\r\n    false\r\n  )\r\n  readonlyInstrumentations[method as string] = createIterableMethod(\r\n    method,\r\n    true,\r\n    false\r\n  )\r\n  shallowInstrumentations[method as string] = createIterableMethod(\r\n    method,\r\n    false,\r\n    true\r\n  )\r\n})\r\n\r\nfunction createInstrumentationGetter(isReadonly: boolean, shallow: boolean) {\r\n  const instrumentations = shallow\r\n    ? shallowInstrumentations\r\n    : isReadonly\r\n      ? readonlyInstrumentations\r\n      : mutableInstrumentations\r\n\r\n  return (\r\n    target: CollectionTypes,\r\n    key: string | symbol,\r\n    receiver: CollectionTypes\r\n  ) => {\r\n    if (key === ReactiveFlags.IS_REACTIVE) {\r\n      return !isReadonly\r\n    } else if (key === ReactiveFlags.IS_READONLY) {\r\n      return isReadonly\r\n    } else if (key === ReactiveFlags.RAW) {\r\n      return target\r\n    }\r\n\r\n    return Reflect.get(\r\n      hasOwn(instrumentations, key) && key in target\r\n        ? instrumentations\r\n        : target,\r\n      key,\r\n      receiver\r\n    )\r\n  }\r\n}\r\n\r\nexport const mutableCollectionHandlers: ProxyHandler<CollectionTypes> = {\r\n  get: createInstrumentationGetter(false, false)\r\n}\r\n\r\nexport const shallowCollectionHandlers: ProxyHandler<CollectionTypes> = {\r\n  get: createInstrumentationGetter(false, true)\r\n}\r\n\r\nexport const readonlyCollectionHandlers: ProxyHandler<CollectionTypes> = {\r\n  get: createInstrumentationGetter(true, false)\r\n}\r\n\r\nfunction checkIdentityKeys(\r\n  target: CollectionTypes,\r\n  has: (key: unknown) => boolean,\r\n  key: unknown\r\n) {\r\n  const rawKey = toRaw(key)\r\n  if (rawKey !== key && has.call(target, rawKey)) {\r\n    const type = toRawType(target)\r\n    console.warn(\r\n      `Reactive ${type} contains both the raw and reactive ` +\r\n        `versions of the same object${type === `Map` ? `as keys` : ``}, ` +\r\n        `which can lead to inconsistencies. ` +\r\n        `Avoid differentiating between the raw and reactive versions ` +\r\n        `of an object and only use the reactive version if possible.`\r\n    )\r\n  }\r\n}\r\n","import { isObject, toRawType, def, hasOwn, makeMap } from '@vue/shared'\r\nimport {\r\n  mutableHandlers,\r\n  readonlyHandlers,\r\n  shallowReactiveHandlers,\r\n  shallowReadonlyHandlers\r\n} from './baseHandlers'\r\nimport {\r\n  mutableCollectionHandlers,\r\n  readonlyCollectionHandlers,\r\n  shallowCollectionHandlers\r\n} from './collectionHandlers'\r\nimport { UnwrapRef, Ref } from './ref'\r\n\r\nexport const enum ReactiveFlags {\r\n  SKIP = '__v_skip',\r\n  IS_REACTIVE = '__v_isReactive',\r\n  IS_READONLY = '__v_isReadonly',\r\n  RAW = '__v_raw',\r\n  REACTIVE = '__v_reactive',\r\n  READONLY = '__v_readonly'\r\n}\r\n\r\ninterface Target {\r\n  [ReactiveFlags.SKIP]?: boolean\r\n  [ReactiveFlags.IS_REACTIVE]?: boolean\r\n  [ReactiveFlags.IS_READONLY]?: boolean\r\n  [ReactiveFlags.RAW]?: any\r\n  [ReactiveFlags.REACTIVE]?: any\r\n  [ReactiveFlags.READONLY]?: any\r\n}\r\n\r\nconst collectionTypes = new Set<Function>([Set, Map, WeakMap, WeakSet])\r\nconst isObservableType = /*#__PURE__*/ makeMap(\r\n  'Object,Array,Map,Set,WeakMap,WeakSet'\r\n)\r\n\r\nconst canObserve = (value: Target): boolean => {\r\n  return (\r\n    !value[ReactiveFlags.SKIP] &&\r\n    isObservableType(toRawType(value)) &&\r\n    Object.isExtensible(value)\r\n  )\r\n}\r\n\r\n// only unwrap nested ref\r\ntype UnwrapNestedRefs<T> = T extends Ref ? T : UnwrapRef<T>\r\n\r\nexport function reactive<T extends object>(target: T): UnwrapNestedRefs<T>\r\nexport function reactive(target: object) {\r\n  // if trying to observe a readonly proxy, return the readonly version.\r\n  if (target && (target as Target)[ReactiveFlags.IS_READONLY]) {\r\n    return target\r\n  }\r\n  return createReactiveObject(\r\n    target,\r\n    false,\r\n    mutableHandlers,\r\n    mutableCollectionHandlers\r\n  )\r\n}\r\n\r\n// Return a reactive-copy of the original object, where only the root level\r\n// properties are reactive, and does NOT unwrap refs nor recursively convert\r\n// returned properties.\r\nexport function shallowReactive<T extends object>(target: T): T {\r\n  return createReactiveObject(\r\n    target,\r\n    false,\r\n    shallowReactiveHandlers,\r\n    shallowCollectionHandlers\r\n  )\r\n}\r\n\r\ntype Primitive = string | number | boolean | bigint | symbol | undefined | null\r\ntype Builtin = Primitive | Function | Date | Error | RegExp\r\nexport type DeepReadonly<T> = T extends Builtin\r\n  ? T\r\n  : T extends Map<infer K, infer V>\r\n    ? ReadonlyMap<DeepReadonly<K>, DeepReadonly<V>>\r\n    : T extends ReadonlyMap<infer K, infer V>\r\n      ? ReadonlyMap<DeepReadonly<K>, DeepReadonly<V>>\r\n      : T extends WeakMap<infer K, infer V>\r\n        ? WeakMap<DeepReadonly<K>, DeepReadonly<V>>\r\n        : T extends Set<infer U>\r\n          ? ReadonlySet<DeepReadonly<U>>\r\n          : T extends ReadonlySet<infer U>\r\n            ? ReadonlySet<DeepReadonly<U>>\r\n            : T extends WeakSet<infer U>\r\n              ? WeakSet<DeepReadonly<U>>\r\n              : T extends Promise<infer U>\r\n                ? Promise<DeepReadonly<U>>\r\n                : T extends {}\r\n                  ? { readonly [K in keyof T]: DeepReadonly<T[K]> }\r\n                  : Readonly<T>\r\n\r\nexport function readonly<T extends object>(\r\n  target: T\r\n): DeepReadonly<UnwrapNestedRefs<T>> {\r\n  return createReactiveObject(\r\n    target,\r\n    true,\r\n    readonlyHandlers,\r\n    readonlyCollectionHandlers\r\n  )\r\n}\r\n\r\n// Return a reactive-copy of the original object, where only the root level\r\n// properties are readonly, and does NOT unwrap refs nor recursively convert\r\n// returned properties.\r\n// This is used for creating the props proxy object for stateful components.\r\nexport function shallowReadonly<T extends object>(\r\n  target: T\r\n): Readonly<{ [K in keyof T]: UnwrapNestedRefs<T[K]> }> {\r\n  return createReactiveObject(\r\n    target,\r\n    true,\r\n    shallowReadonlyHandlers,\r\n    readonlyCollectionHandlers\r\n  )\r\n}\r\n\r\nfunction createReactiveObject(\r\n  target: Target,\r\n  isReadonly: boolean,\r\n  baseHandlers: ProxyHandler<any>,\r\n  collectionHandlers: ProxyHandler<any>\r\n) {\r\n  if (!isObject(target)) {\r\n    if (__DEV__) {\r\n      console.warn(`value cannot be made reactive: ${String(target)}`)\r\n    }\r\n    return target\r\n  }\r\n  // target is already a Proxy, return it.\r\n  // exception: calling readonly() on a reactive object\r\n  if (\r\n    target[ReactiveFlags.RAW] &&\r\n    !(isReadonly && target[ReactiveFlags.IS_REACTIVE])\r\n  ) {\r\n    return target\r\n  }\r\n  // target already has corresponding Proxy\r\n  const reactiveFlag = isReadonly\r\n    ? ReactiveFlags.READONLY\r\n    : ReactiveFlags.REACTIVE\r\n  if (hasOwn(target, reactiveFlag)) {\r\n    return target[reactiveFlag]\r\n  }\r\n  // only a whitelist of value types can be observed.\r\n  if (!canObserve(target)) {\r\n    return target\r\n  }\r\n  const observed = new Proxy(\r\n    target,\r\n    collectionTypes.has(target.constructor) ? collectionHandlers : baseHandlers\r\n  )\r\n  def(target, reactiveFlag, observed)\r\n  return observed\r\n}\r\n\r\nexport function isReactive(value: unknown): boolean {\r\n  if (isReadonly(value)) {\r\n    return isReactive((value as Target)[ReactiveFlags.RAW])\r\n  }\r\n  return !!(value && (value as Target)[ReactiveFlags.IS_REACTIVE])\r\n}\r\n\r\nexport function isReadonly(value: unknown): boolean {\r\n  return !!(value && (value as Target)[ReactiveFlags.IS_READONLY])\r\n}\r\n\r\nexport function isProxy(value: unknown): boolean {\r\n  return isReactive(value) || isReadonly(value)\r\n}\r\n\r\nexport function toRaw<T>(observed: T): T {\r\n  return (\r\n    (observed && toRaw((observed as Target)[ReactiveFlags.RAW])) || observed\r\n  )\r\n}\r\n\r\nexport function markRaw<T extends object>(value: T): T {\r\n  def(value, ReactiveFlags.SKIP, true)\r\n  return value\r\n}\r\n","import { track, trigger } from './effect'\r\nimport { TrackOpTypes, TriggerOpTypes } from './operations'\r\nimport { isObject, hasChanged } from '@vue/shared'\r\nimport { reactive, isProxy, toRaw, isReactive } from './reactive'\r\nimport { CollectionTypes } from './collectionHandlers'\r\n\r\ndeclare const RefSymbol: unique symbol\r\n\r\nexport interface Ref<T = any> {\r\n  /**\r\n   * Type differentiator only.\r\n   * We need this to be in public d.ts but don't want it to show up in IDE\r\n   * autocomplete, so we use a private Symbol instead.\r\n   */\r\n  [RefSymbol]: true\r\n  value: T\r\n}\r\n\r\nexport type ToRefs<T = any> = { [K in keyof T]: Ref<T[K]> }\r\n\r\nconst convert = <T extends unknown>(val: T): T =>\r\n  isObject(val) ? reactive(val) : val\r\n\r\nexport function isRef<T>(r: Ref<T> | unknown): r is Ref<T>\r\nexport function isRef(r: any): r is Ref {\r\n  return r ? r.__v_isRef === true : false\r\n}\r\n\r\nexport function ref<T extends object>(\r\n  value: T\r\n): T extends Ref ? T : Ref<UnwrapRef<T>>\r\nexport function ref<T>(value: T): Ref<UnwrapRef<T>>\r\nexport function ref<T = any>(): Ref<T | undefined>\r\nexport function ref(value?: unknown) {\r\n  return createRef(value)\r\n}\r\n\r\nexport function shallowRef<T>(value: T): T extends Ref ? T : Ref<T>\r\nexport function shallowRef<T = any>(): Ref<T | undefined>\r\nexport function shallowRef(value?: unknown) {\r\n  return createRef(value, true)\r\n}\r\n\r\nfunction createRef(rawValue: unknown, shallow = false) {\r\n  if (isRef(rawValue)) {\r\n    return rawValue\r\n  }\r\n  let value = shallow ? rawValue : convert(rawValue)\r\n  const r = {\r\n    __v_isRef: true,\r\n    get value() {\r\n      track(r, TrackOpTypes.GET, 'value')\r\n      return value\r\n    },\r\n    set value(newVal) {\r\n      if (hasChanged(toRaw(newVal), rawValue)) {\r\n        rawValue = newVal\r\n        value = shallow ? newVal : convert(newVal)\r\n        trigger(r, TriggerOpTypes.SET, 'value', newVal)\r\n      }\r\n    }\r\n  }\r\n  return r\r\n}\r\n\r\nexport function triggerRef(ref: Ref) {\r\n  trigger(ref, TriggerOpTypes.SET, 'value', __DEV__ ? ref.value : void 0)\r\n}\r\n\r\nexport function unref<T>(ref: T): T extends Ref<infer V> ? V : T {\r\n  return isRef(ref) ? (ref.value as any) : ref\r\n}\r\n\r\nconst shallowUnwrapHandlers: ProxyHandler<any> = {\r\n  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\r\n  set: (target, key, value, receiver) => {\r\n    const oldValue = target[key]\r\n    if (isRef(oldValue) && !isRef(value)) {\r\n      oldValue.value = value\r\n      return true\r\n    } else {\r\n      return Reflect.set(target, key, value, receiver)\r\n    }\r\n  }\r\n}\r\n\r\nexport function proxyRefs<T extends object>(\r\n  objectWithRefs: T\r\n): ShallowUnwrapRef<T> {\r\n  return isReactive(objectWithRefs)\r\n    ? objectWithRefs\r\n    : new Proxy(objectWithRefs, shallowUnwrapHandlers)\r\n}\r\n\r\nexport type CustomRefFactory<T> = (\r\n  track: () => void,\r\n  trigger: () => void\r\n) => {\r\n  get: () => T\r\n  set: (value: T) => void\r\n}\r\n\r\nexport function customRef<T>(factory: CustomRefFactory<T>): Ref<T> {\r\n  const { get, set } = factory(\r\n    () => track(r, TrackOpTypes.GET, 'value'),\r\n    () => trigger(r, TriggerOpTypes.SET, 'value')\r\n  )\r\n  const r = {\r\n    __v_isRef: true,\r\n    get value() {\r\n      return get()\r\n    },\r\n    set value(v) {\r\n      set(v)\r\n    }\r\n  }\r\n  return r as any\r\n}\r\n\r\nexport function toRefs<T extends object>(object: T): ToRefs<T> {\r\n  if (__DEV__ && !isProxy(object)) {\r\n    console.warn(`toRefs() expects a reactive object but received a plain one.`)\r\n  }\r\n  const ret: any = {}\r\n  for (const key in object) {\r\n    ret[key] = toRef(object, key)\r\n  }\r\n  return ret\r\n}\r\n\r\nexport function toRef<T extends object, K extends keyof T>(\r\n  object: T,\r\n  key: K\r\n): Ref<T[K]> {\r\n  return {\r\n    __v_isRef: true,\r\n    get value(): any {\r\n      return object[key]\r\n    },\r\n    set value(newVal) {\r\n      object[key] = newVal\r\n    }\r\n  } as any\r\n}\r\n\r\n// corner case when use narrows type\r\n// Ex. type RelativePath = string & { __brand: unknown }\r\n// RelativePath extends object -> true\r\ntype BaseTypes = string | number | boolean\r\n\r\n/**\r\n * This is a special exported interface for other packages to declare\r\n * additional types that should bail out for ref unwrapping. For example\r\n * \\@vue/runtime-dom can declare it like so in its d.ts:\r\n *\r\n * ``` ts\r\n * declare module '@vue/reactivity' {\r\n *   export interface RefUnwrapBailTypes {\r\n *     runtimeDOMBailTypes: Node | Window\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * Note that api-extractor somehow refuses to include `declare module`\r\n * augmentations in its generated d.ts, so we have to manually append them\r\n * to the final generated d.ts in our build process.\r\n */\r\nexport interface RefUnwrapBailTypes {}\r\n\r\nexport type ShallowUnwrapRef<T> = {\r\n  [K in keyof T]: T[K] extends Ref<infer V> ? V : T[K]\r\n}\r\n\r\nexport type UnwrapRef<T> = T extends Ref<infer V>\r\n  ? UnwrapRefSimple<V>\r\n  : UnwrapRefSimple<T>\r\n\r\ntype UnwrapRefSimple<T> = T extends\r\n  | Function\r\n  | CollectionTypes\r\n  | BaseTypes\r\n  | Ref\r\n  | RefUnwrapBailTypes[keyof RefUnwrapBailTypes]\r\n  ? T\r\n  : T extends Array<any>\r\n    ? { [K in keyof T]: UnwrapRefSimple<T[K]> }\r\n    : T extends object ? UnwrappedObject<T> : T\r\n\r\n// Extract all known symbols from an object\r\n// when unwrapping Object the symbols are not `in keyof`, this should cover all the\r\n// known symbols\r\ntype SymbolExtract<T> = (T extends { [Symbol.asyncIterator]: infer V }\r\n  ? { [Symbol.asyncIterator]: V }\r\n  : {}) &\r\n  (T extends { [Symbol.hasInstance]: infer V }\r\n    ? { [Symbol.hasInstance]: V }\r\n    : {}) &\r\n  (T extends { [Symbol.isConcatSpreadable]: infer V }\r\n    ? { [Symbol.isConcatSpreadable]: V }\r\n    : {}) &\r\n  (T extends { [Symbol.iterator]: infer V } ? { [Symbol.iterator]: V } : {}) &\r\n  (T extends { [Symbol.match]: infer V } ? { [Symbol.match]: V } : {}) &\r\n  (T extends { [Symbol.matchAll]: infer V } ? { [Symbol.matchAll]: V } : {}) &\r\n  (T extends { [Symbol.replace]: infer V } ? { [Symbol.replace]: V } : {}) &\r\n  (T extends { [Symbol.search]: infer V } ? { [Symbol.search]: V } : {}) &\r\n  (T extends { [Symbol.species]: infer V } ? { [Symbol.species]: V } : {}) &\r\n  (T extends { [Symbol.split]: infer V } ? { [Symbol.split]: V } : {}) &\r\n  (T extends { [Symbol.toPrimitive]: infer V }\r\n    ? { [Symbol.toPrimitive]: V }\r\n    : {}) &\r\n  (T extends { [Symbol.toStringTag]: infer V }\r\n    ? { [Symbol.toStringTag]: V }\r\n    : {}) &\r\n  (T extends { [Symbol.unscopables]: infer V }\r\n    ? { [Symbol.unscopables]: V }\r\n    : {})\r\n\r\ntype UnwrappedObject<T> = { [P in keyof T]: UnwrapRef<T[P]> } & SymbolExtract<T>\r\n","import { effect, ReactiveEffect, trigger, track } from './effect'\r\nimport { TriggerOpTypes, TrackOpTypes } from './operations'\r\nimport { Ref } from './ref'\r\nimport { isFunction, NOOP } from '@vue/shared'\r\nimport { ReactiveFlags } from './reactive'\r\n\r\nexport interface ComputedRef<T = any> extends WritableComputedRef<T> {\r\n  readonly value: T\r\n}\r\n\r\nexport interface WritableComputedRef<T> extends Ref<T> {\r\n  readonly effect: ReactiveEffect<T>\r\n}\r\n\r\nexport type ComputedGetter<T> = (ctx?: any) => T\r\nexport type ComputedSetter<T> = (v: T) => void\r\n\r\nexport interface WritableComputedOptions<T> {\r\n  get: ComputedGetter<T>\r\n  set: ComputedSetter<T>\r\n}\r\n\r\nexport function computed<T>(getter: ComputedGetter<T>): ComputedRef<T>\r\nexport function computed<T>(\r\n  options: WritableComputedOptions<T>\r\n): WritableComputedRef<T>\r\nexport function computed<T>(\r\n  getterOrOptions: ComputedGetter<T> | WritableComputedOptions<T>\r\n) {\r\n  let getter: ComputedGetter<T>\r\n  let setter: ComputedSetter<T>\r\n\r\n  if (isFunction(getterOrOptions)) {\r\n    getter = getterOrOptions\r\n    setter = __DEV__\r\n      ? () => {\r\n          console.warn('Write operation failed: computed value is readonly')\r\n        }\r\n      : NOOP\r\n  } else {\r\n    getter = getterOrOptions.get\r\n    setter = getterOrOptions.set\r\n  }\r\n\r\n  let dirty = true\r\n  let value: T\r\n  let computed: ComputedRef<T>\r\n\r\n  const runner = effect(getter, {\r\n    lazy: true,\r\n    scheduler: () => {\r\n      if (!dirty) {\r\n        dirty = true\r\n        trigger(computed, TriggerOpTypes.SET, 'value')\r\n      }\r\n    }\r\n  })\r\n  computed = {\r\n    __v_isRef: true,\r\n    [ReactiveFlags.IS_READONLY]:\r\n      isFunction(getterOrOptions) || !getterOrOptions.set,\r\n\r\n    // expose effect so computed can be stopped\r\n    effect: runner,\r\n    get value() {\r\n      if (dirty) {\r\n        value = runner()\r\n        dirty = false\r\n      }\r\n      track(computed, TrackOpTypes.GET, 'value')\r\n      return value\r\n    },\r\n    set value(newValue: T) {\r\n      setter(newValue)\r\n    }\r\n  } as any\r\n  return computed\r\n}\r\n"],"names":["makeMap","str","expectsLowerCase","map","Object","create","list","split","i","length","val","toLowerCase","EMPTY_OBJ","NOOP","extend","assign","hasOwnProperty","prototype","hasOwn","key","call","isArray","Array","isFunction","isSymbol","isObject","objectToString","toString","toRawType","value","toTypeString","slice","hasChanged","oldValue","def","obj","defineProperty","configurable","enumerable","targetMap","WeakMap","effectStack","activeEffect","ITERATE_KEY","Symbol","MAP_KEY_ITERATE_KEY","effect","fn","options","_isEffect","isEffect","raw","active","scheduler","undefined","includes","cleanup","enableTracking","push","pop","resetTracking","id","uid","deps","createReactiveEffect","lazy","stop","onStop","delete","shouldTrack","trackStack","pauseTracking","last","track","target","type","depsMap","get","set","Map","dep","Set","has","add","trigger","newValue","oldTarget","effects","effectsToAdd","forEach","isAddOrDelete","builtInSymbols","getOwnPropertyNames","filter","createGetter","shallowGet","readonlyGet","shallowReadonlyGet","arrayInstrumentations","isReadonly","shallow","receiver","targetIsArray","Reflect","res","isRef","readonly","reactive","args","arr","toRaw","this","l","createSetter","hadKey","result","ownKeys","mutableHandlers","deleteProperty","readonlyHandlers","shallowReactiveHandlers","shallowReadonlyHandlers","toReactive","toReadonly","toShallow","getProto","v","getPrototypeOf","wrap","rawKey","size","proto","deleteEntry","del","clear","hadItems","createForEach","callback","thisArg","observed","createIterableMethod","method","isMap","isPair","iterator","isKeyOnly","innerIterator","apply","[object Object]","done","next","createReadonlyMethod","mutableInstrumentations","shallowInstrumentations","readonlyInstrumentations","createInstrumentationGetter","instrumentations","mutableCollectionHandlers","shallowCollectionHandlers","readonlyCollectionHandlers","collectionTypes","WeakSet","isObservableType","createReactiveObject","shallowReactive","shallowReadonly","baseHandlers","collectionHandlers","reactiveFlag","isExtensible","Proxy","constructor","isReactive","isProxy","markRaw","convert","r","__v_isRef","ref","createRef","shallowRef","rawValue","newVal","triggerRef","unref","shallowUnwrapHandlers","proxyRefs","objectWithRefs","customRef","factory","toRefs","object","ret","toRef","computed","getterOrOptions","getter","setter","dirty","runner","__v_isReadonly"],"mappings":"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"}